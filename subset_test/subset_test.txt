22 June 2024   8:51:33.468 PM

subset_test():
  Fortran90 version
  Test subset().

asm_enum_test():
  asm_enum() returns the number of alternating sign
  matrices of a given order.

   0         1
   1         1
   2         2
   3         7
   4        42
   5       429
   6      7436
   7    218348

ASM_TRIANGLE_test():
  ASM_TRIANGLE returns a row of the alternating sign
  matrix triangle.

   0         1
   1         1       1
   2         2       3       2
   3         7      14      14       7
   4        42     105     135     105      42
   5       429    1287    2002    2002    1287     429
   6      7436   26026   47320   56784   47320   26026    7436
   7    218348  873392 1813968 2519400 2519400 1813968  873392  218348

BELL_test():
  BELL computes Bell numbers.

  N  exact C(I)  computed C(I)

     0         1         1
     1         1         1
     2         2         2
     3         5         5
     4        15        15
     5        52        52
     6       203       203
     7       877       877
     8      4140      4140
     9     21147     21147
    10    115975    115975

catalan_number_test():
  catalan_number() computes a Catalan number.

  N   C(N)

     0       1
     1       1
     2       2
     3       5
     4      14
     5      42
     6     132
     7     429
     8    1430
     9    4862
    10   16796
    11   58786
    12  208012
    13  742900
    14 2674440
    15 9694845

catalan_numbers_test():
  catalan_numbers() computes Catalan numbers.

  N  exact C(I)  computed C(I)

     0       1       1
     1       1       1
     2       2       2
     3       5       5
     4      14      14
     5      42      42
     6     132     132
     7     429     429
     8    1430    1430
     9    4862    4862
    10   16796   16796

CATALAN_ROW_NEXT_test():
  CATALAN_ROW_NEXT computes a row of Catalan's triangle.

  First, compute row 7:
   7       1     7    27    75   165   297   429   429

  Now compute rows one at a time:

   0       1
   1       1     1
   2       1     2     2
   3       1     3     5     5
   4       1     4     9    14    14
   5       1     5    14    28    42    42
   6       1     6    20    48    90   132   132
   7       1     7    27    75   165   297   429   429
   8       1     8    35   110   275   572  1001  1430  1430
   9       1     9    44   154   429  1001  2002  3432  4862  4862
  10       1    10    54   208   637  1638  3640  7072 11934 16796 16796

CFRAC_TO_RAT_test():
  CFRAC_TO_RAT continued fraction => fraction.

  Regular fraction is     4096 /    15625

  Continued fraction coefficients:

       1         0
       2         3
       3         1
       4         4
       5         2
       6         1
       7         1
       8        11
       9        13

  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.

  I, P(I), Q(I), P(I)/Q(I)

    1       0       1   0.00000    
    2       1       3  0.333333    
    3       1       4  0.250000    
    4       5      19  0.263158    
    5      11      42  0.261905    
    6      16      61  0.262295    
    7      27     103  0.262136    
    8     313    1194  0.262144    
    9    4096   15625  0.262144    

CFRAC_TO_RFRAC_test():
  CFRAC_TO_RFRAC: continued fraction to ratio.

  Rational polynomial fraction coefficients:

  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000

  Continued fraction coefficients:

       1   1.00000    
       2  0.500000    
       3   1.33333    
       4 -0.500000    
       5  -1.50000    
       6   2.00000    

  Recovered rational polynomial:

  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000

CHANGE_GREEDY_test():
  CHANGE_GREEDY makes change using the biggest
  coins first.

  The total for which change is to be made:       73

  The available coins are:

         1
         5
        10
        25
        50
       100

         6      5  3  3  1  1  1
        73     50 10 10  1  1  1

CHANGE_NEXT_test():
  CHANGE_NEXT displays the next possible way to make
  change for a given total

  The total for which change is to be made:       50


  The available coins are:

         1
         5
        10
        25
        50
       100

  1:
   50

  2:
   25 25

  3:
   25 10 10  5

  4:
   25 10 10  1  1  1  1  1

  5:
   25 10  5  5  5

  6:
   25 10  5  5  1  1  1  1  1

  7:
   25 10  5  1  1  1  1  1  1  1  1  1  1

  8:
   25 10  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1

  9:
   25  5  5  5  5  5

 10:
   25  5  5  5  5  1  1  1  1  1

CHINESE_CHECK_test():
  CHINESE_CHECK checks a set of moduluses for suitability
  with the Chinese Remainder representation.

  Modulus set #1:

       1         1
       2         3
       3         8
       4        25
  Error flag =    0

  Modulus set #2:

       1         1
       2         3
       3        -8
       4        25
  Error flag =    1

  Modulus set #3:

       1         1
       2         3
       3         1
       4        25
  Error flag =    2

  Modulus set #4:

       1         1
       2         3
       3         8
       4        24
  Error flag =    3

CHINESE_TO_I4_test():
  CHINESE_TO_I4 computes an integer with the given
  Chinese Remainder representation.

  The moduli:

       1         3
       2         4
       3         5
       4         7

  The number being analyzed is       37

  The remainders:

       1         1
       2         1
       3         2
       4         2

  The reconstructed number is       37

  The remainders of the reconstructed number are:

       1         1
       2         1
       3         2
       4         2

COMB_NEXT_test():
  COMB_NEXT produces combinations.

  Combinations of size K =        1

    1
    2
    3
    4
    5

  Combinations of size K =        2

    1  2
    1  3
    1  4
    1  5
    2  3
    2  4
    2  5
    3  4
    3  5
    4  5

  Combinations of size K =        3

    1  2  3
    1  2  4
    1  2  5
    1  3  4
    1  3  5
    1  4  5
    2  3  4
    2  3  5
    2  4  5
    3  4  5

  Combinations of size K =        4

    1  2  3  4
    1  2  3  5
    1  2  4  5
    1  3  4  5
    2  3  4  5

  Combinations of size K =        5

    1  2  3  4  5

COMB_ROW_NEXT_test():
  COMB_ROW computes a row of Pascal's triangle.

   0      1
   1      1    1
   2      1    2    1
   3      1    3    3    1
   4      1    4    6    4    1
   5      1    5   10   10    5    1
   6      1    6   15   20   15    6    1
   7      1    7   21   35   35   21    7    1
   8      1    8   28   56   70   56   28    8    1
   9      1    9   36   84  126  126   84   36    9    1
  10      1   10   45  120  210  252  210  120   45   10    1

COMB_UNRANK_test():
  COMB_UNRANK returns a combination of N things
  out of M, given the lexicographic rank.

  The total set size is M =       10
  The subset size is N =           5
  The number of combinations of N out of M is      252

   Rank	  Combination

    1      1   2   3   4   5
    2      1   2   3   4   6
    3      1   2   3   4   7
    6      1   2   3   4  10
    7      1   2   3   5   6
    8      1   2   3   5   7
  250      5   6   8   9  10
  251      5   7   8   9  10
  252      6   7   8   9  10


COMP_ENUM_test():
  COMP_ENUM counts compositions;

       1       1       1       1       1       1       1       1       1       1
       1       2       3       4       5       6       7       8       9      10
       1       3       6      10      15      21      28      36      45      55
       1       4      10      20      35      56      84     120     165     220
       1       5      15      35      70     126     210     330     495     715
       1       6      21      56     126     252     462     792    1287    2002
       1       7      28      84     210     462     924    1716    3003    5005
       1       8      36     120     330     792    1716    3432    6435   11440
       1       9      45     165     495    1287    3003    6435   12870   24310
       1      10      55     220     715    2002    5005   11440   24310   48620
       1      11      66     286    1001    3003    8008   19448   43758   92378

COMP_NEXT_test():
  COMP_NEXT generates compositions.

  Seeking all compositions of N =        6
  using        3 parts.
     1     6   0   0
     2     5   1   0
     3     4   2   0
     4     3   3   0
     5     2   4   0
     6     1   5   0
     7     0   6   0
     8     5   0   1
     9     4   1   1
    10     3   2   1
    11     2   3   1
    12     1   4   1
    13     0   5   1
    14     4   0   2
    15     3   1   2
    16     2   2   2
    17     1   3   2
    18     0   4   2
    19     3   0   3
    20     2   1   3
    21     1   2   3
    22     0   3   3
    23     2   0   4
    24     1   1   4
    25     0   2   4
    26     1   0   5
    27     0   1   5
    28     0   0   6

COMP_NEXT_GRLEX_test():
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_NEXT_GRLEX determines the next COMP in
  graded lexicographic (grlex) order.

  Rank:     NC       COMP    
  ----:     --   ------------
     1:      0 =  0 +  0 +  0
  ----:     --   ------------
     2:      1 =  0 +  0 +  1
     3:      1 =  0 +  1 +  0
     4:      1 =  1 +  0 +  0
  ----:     --   ------------
     5:      2 =  0 +  0 +  2
     6:      2 =  0 +  1 +  1
     7:      2 =  0 +  2 +  0
     8:      2 =  1 +  0 +  1
     9:      2 =  1 +  1 +  0
    10:      2 =  2 +  0 +  0
  ----:     --   ------------
    11:      3 =  0 +  0 +  3
    12:      3 =  0 +  1 +  2
    13:      3 =  0 +  2 +  1
    14:      3 =  0 +  3 +  0
    15:      3 =  1 +  0 +  2
    16:      3 =  1 +  1 +  1
    17:      3 =  1 +  2 +  0
    18:      3 =  2 +  0 +  1
    19:      3 =  2 +  1 +  0
    20:      3 =  3 +  0 +  0
  ----:     --   ------------
    21:      4 =  0 +  0 +  4
    22:      4 =  0 +  1 +  3
    23:      4 =  0 +  2 +  2
    24:      4 =  0 +  3 +  1
    25:      4 =  0 +  4 +  0
    26:      4 =  1 +  0 +  3
    27:      4 =  1 +  1 +  2
    28:      4 =  1 +  2 +  1
    29:      4 =  1 +  3 +  0
    30:      4 =  2 +  0 +  2
    31:      4 =  2 +  1 +  1
    32:      4 =  2 +  2 +  0
    33:      4 =  3 +  0 +  1
    34:      4 =  3 +  1 +  0
    35:      4 =  4 +  0 +  0
  ----:     --   ------------
    36:      5 =  0 +  0 +  5
    37:      5 =  0 +  1 +  4
    38:      5 =  0 +  2 +  3
    39:      5 =  0 +  3 +  2
    40:      5 =  0 +  4 +  1
    41:      5 =  0 +  5 +  0
    42:      5 =  1 +  0 +  4
    43:      5 =  1 +  1 +  3
    44:      5 =  1 +  2 +  2
    45:      5 =  1 +  3 +  1
    46:      5 =  1 +  4 +  0
    47:      5 =  2 +  0 +  3
    48:      5 =  2 +  1 +  2
    49:      5 =  2 +  2 +  1
    50:      5 =  2 +  3 +  0
    51:      5 =  3 +  0 +  2
    52:      5 =  3 +  1 +  1
    53:      5 =  3 +  2 +  0
    54:      5 =  4 +  0 +  1
    55:      5 =  4 +  1 +  0
    56:      5 =  5 +  0 +  0
  ----:     --   ------------
    57:      6 =  0 +  0 +  6
    58:      6 =  0 +  1 +  5
    59:      6 =  0 +  2 +  4
    60:      6 =  0 +  3 +  3
    61:      6 =  0 +  4 +  2
    62:      6 =  0 +  5 +  1
    63:      6 =  0 +  6 +  0
    64:      6 =  1 +  0 +  5
    65:      6 =  1 +  1 +  4
    66:      6 =  1 +  2 +  3
    67:      6 =  1 +  3 +  2
    68:      6 =  1 +  4 +  1
    69:      6 =  1 +  5 +  0
    70:      6 =  2 +  0 +  4
    71:      6 =  2 +  1 +  3

comp_random_test():
  comp_random() generates random compositions.

  Seeking random compositions of N =       10
  using        5 parts.

     2   3   2   0   3
     2   1   2   4   1
     0   2   6   0   2
     1   0   0   4   5
     0   0   6   3   1

comp_random_grlex_test():
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_RANDOM_GRLEX selects a random COMP in
  graded lexicographic (grlex) order between
  indices RANK1 and RANK2.

    41:      5 =  0 +  5 +  0
    20:      3 =  3 +  0 +  0
    33:      4 =  3 +  0 +  1
    57:      6 =  0 +  0 +  6
    44:      5 =  1 +  2 +  2

COMP_RANK_GRLEX_test():
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_RANK_GRLEX determines the rank of a COMP
  from its parts.

        Actual  Inferred
  Test    Rank      Rank

     1      26        26
     2      56        56
     3      35        35
     4      47        47
     5      59        59

COMP_TO_KSUB_test():
  comp_to_ksub() returns the K subset corresponding to a composition.

  COMP:   0   1   1   6   2
  KSUB:   1   3   5  12
  COMP:   0   1   1   6   2

  COMP:   1   6   1   2   0
  KSUB:   2   9  11  14
  COMP:   1   6   1   2   0

  COMP:   0   4   0   5   1
  KSUB:   1   6   7  13
  COMP:   0   4   0   5   1

  COMP:   2   4   0   2   2
  KSUB:   3   8   9  12
  COMP:   2   4   0   2   2

  COMP:   0   2   0   4   4
  KSUB:   1   4   5  10
  COMP:   0   2   0   4   4

COMP_UNRANK_GRLEX_test():
  A COMP is a composition of an integer N into K parts.
  Each part is nonnegative.  The order matters.
  COMP_UNRANK_GRLEX determines the parts
  of a COMP from its rank.

  Rank: ->  NC       COMP
  ----:     --   ------------
     1:      0 =  0 +  0 +  0
  ----:     --   ------------
     2:      1 =  0 +  0 +  1
     3:      1 =  0 +  1 +  0
     4:      1 =  1 +  0 +  0
  ----:     --   ------------
     5:      2 =  0 +  0 +  2
     6:      2 =  0 +  1 +  1
     7:      2 =  0 +  2 +  0
     8:      2 =  1 +  0 +  1
     9:      2 =  1 +  1 +  0
    10:      2 =  2 +  0 +  0
  ----:     --   ------------
    11:      3 =  0 +  0 +  3
    12:      3 =  0 +  1 +  2
    13:      3 =  0 +  2 +  1
    14:      3 =  0 +  3 +  0
    15:      3 =  1 +  0 +  2
    16:      3 =  1 +  1 +  1
    17:      3 =  1 +  2 +  0
    18:      3 =  2 +  0 +  1
    19:      3 =  2 +  1 +  0
    20:      3 =  3 +  0 +  0
  ----:     --   ------------
    21:      4 =  0 +  0 +  4
    22:      4 =  0 +  1 +  3
    23:      4 =  0 +  2 +  2
    24:      4 =  0 +  3 +  1
    25:      4 =  0 +  4 +  0
    26:      4 =  1 +  0 +  3
    27:      4 =  1 +  1 +  2
    28:      4 =  1 +  2 +  1
    29:      4 =  1 +  3 +  0
    30:      4 =  2 +  0 +  2
    31:      4 =  2 +  1 +  1
    32:      4 =  2 +  2 +  0
    33:      4 =  3 +  0 +  1
    34:      4 =  3 +  1 +  0
    35:      4 =  4 +  0 +  0
  ----:     --   ------------
    36:      5 =  0 +  0 +  5
    37:      5 =  0 +  1 +  4
    38:      5 =  0 +  2 +  3
    39:      5 =  0 +  3 +  2
    40:      5 =  0 +  4 +  1
    41:      5 =  0 +  5 +  0
    42:      5 =  1 +  0 +  4
    43:      5 =  1 +  1 +  3
    44:      5 =  1 +  2 +  2
    45:      5 =  1 +  3 +  1
    46:      5 =  1 +  4 +  0
    47:      5 =  2 +  0 +  3
    48:      5 =  2 +  1 +  2
    49:      5 =  2 +  2 +  1
    50:      5 =  2 +  3 +  0
    51:      5 =  3 +  0 +  2
    52:      5 =  3 +  1 +  1
    53:      5 =  3 +  2 +  0
    54:      5 =  4 +  0 +  1
    55:      5 =  4 +  1 +  0
    56:      5 =  5 +  0 +  0
  ----:     --   ------------
    57:      6 =  0 +  0 +  6
    58:      6 =  0 +  1 +  5
    59:      6 =  0 +  2 +  4
    60:      6 =  0 +  3 +  3
    61:      6 =  0 +  4 +  2
    62:      6 =  0 +  5 +  1
    63:      6 =  0 +  6 +  0
    64:      6 =  1 +  0 +  5
    65:      6 =  1 +  1 +  4
    66:      6 =  1 +  2 +  3
    67:      6 =  1 +  3 +  2
    68:      6 =  1 +  4 +  1
    69:      6 =  1 +  5 +  0
    70:      6 =  2 +  0 +  4
    71:      6 =  2 +  1 +  3

COMPNZ_ENUM_test():
  COMPNZ_ENUM enumerates compositions with nonzero parts.

  Seeking all compositions of N =        6
  using        3 nonzero parts.

  The number of these compositions is       10

COMPNZ_NEXT_test():
  COMPNZ_NEXT generates compositions with nonzero parts.

  Seeking all compositions of N =        6
  using        3 nonzero parts.
     1     4   1   1
     2     3   2   1
     3     2   3   1
     4     1   4   1
     5     3   1   2
     6     2   2   2
     7     1   3   2
     8     2   1   3
     9     1   2   3
    10     1   1   4

COMPNZ_RANDOM_test():
  COMPNZ_RANDOM generates random compositions
  with nonzero parts.

  Seeking random compositions of N =       10
  using        5 nonzero parts.

     2   2   1   4   1
     2   4   1   1   2
     1   4   1   2   2
     2   3   1   1   3
     1   1   5   1   2

COMPNZ_TO_KSUB_test():
  COMPNZ_TO_KSUB returns the K subset corresponding 
  to a nonzero composition.

  COMPNZ:   2   4   2   1   1
  KSUB:     2   6   8   9
  COMPNZ:   2   4   2   1   1

  COMPNZ:   2   1   2   4   1
  KSUB:     2   3   5   9
  COMPNZ:   2   1   2   4   1

  COMPNZ:   1   1   6   1   1
  KSUB:     1   2   8   9
  COMPNZ:   1   1   6   1   1

  COMPNZ:   1   5   1   1   2
  KSUB:     1   6   7   8
  COMPNZ:   1   5   1   1   2

  COMPNZ:   1   1   3   4   1
  KSUB:     1   2   5   9
  COMPNZ:   1   1   3   4   1

CONGRUENCE_test():
  CONGRUENCE solves a congruence equation:
    A * X = C mod ( B )

   I        A         B         C         X     Mod ( A*X-C,B)

   1        1027       712         7       269         0
   2        1027       712        -7       443         0
   3        1027      -712         7     -1155         0
   4        1027      -712        -7       443         0
   5       -1027       712         7       443         0
   6       -1027       712        -7       269         0
   7       -1027      -712         7       443         0
   8       -1027      -712        -7     -1155         0
   9           6         8        50         7         0
  10           0         0         0         0         0
  11           0         1         0         0         0
  12           0         1         1         0         0
  13           1         0         0         0         0
  14           1         0         1         1         0
  15           1         1         0         1         0
  16        1024    -15625     11529    -15629         0
  17           0         0         1 Error code =          1
  18           0         3        11 Error code =          2
  19           5         0        19 Error code =          3
  20           2         4         7 Error code =          4
  21           7        19         1        11         0

count_pose_random_test():
  count_pose_random() poses a random problem for 
  the game "The Count is Good".

  Problem #       1

    The goal number:

           276

    The available numbers are 

         2   3   7   8   9  10

  Problem #       2

    The goal number:

           260

    The available numbers are 

         1   7   9  10  25  75

  Problem #       3

    The goal number:

           638

    The available numbers are 

         1   2   4   5   6  50

  Problem #       4

    The goal number:

           101

    The available numbers are 

         1   5   9  10  50  75

  Problem #       5

    The goal number:

           331

    The available numbers are 

         1   3   6   8   9  10

DEBRUIJN_test():
  DEBRUIJN computes a de Bruijn string.

  The alphabet size is M =        2
  The string length is N =        3

    21222111

  The alphabet size is M =        3
  The string length is N =        3

    212221132131232231332333111

  The alphabet size is M =        2
  The string length is N =        4

    2121122122221111

DEC_ADD_test():
  DEC_ADD adds two decimals.

  Number of decimal places is        3

  A = 12.8
  B = 4.38
  C = 17.2

DEC_DIV_test():
  DEC_DIV divides two decimals.

  Number of decimal places is        3

  A = 52.3
  B = 13400
  C = 0.0039

DEC_MUL_test():
  DEC_MUL multiplies two decimals.

  Number of decimal places is        2

  A = 0.0014
  B = 1600
  C = 2.2

DEC_ROUND_test():
  DEC_ROUND "rounds" a decimal to a number of digits.

           -----Before-------  -----After--------
  Digits   Mantissa  Exponent  Mantissa  Exponent

         1     523      -1           5       1
         2     523      -1          52       0
         3     523      -1         523      -1
         4     523      -1         523      -1
         2    6340       2          63       4
         3    6340       2         634       3
         4    6340       2         634       3

dec_to_r8_test():
  dec_to_r8() converts a decimal to a real number.

  The number of decimal digits is   5

     R   =>  A * 10^B  =>  R2

   -4.330645    -43306        -4   -4.330600
   -7.542157    -75422        -4   -7.542200
   -3.807339    -38073        -4   -3.807300
   -1.735647    -17356        -4   -1.735600
   -7.397432    -73974        -4   -7.397400
    7.475582     74756        -4    7.475600
   -1.279952      -128        -2   -1.280000
   -9.077144    -90771        -4   -9.077100
    1.392612     13926        -4    1.392600
   -5.791488    -57915        -4   -5.791500

dec_to_rat_test():
  dec_to_rat() decimal => fraction.

  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.

  Then convert to decimal, and the equivalent real.

  Then convert back to rational and the equivalent real.

    0.176259=          98/         556
    0.176259=  1762589928*10^         -10
    1.250006=   220323741/   176258176

    1.790441=         487/         272
    1.790441=  1790441176*10^          -9
    1.790441=   223805147/   125000000

   -0.696581=        -489/         702
   -0.696581=  -696581196*10^          -9
   -0.696581=  -174145299/   250000000

   -1.019002=        -858/         842
   -1.019002= -1019002375*10^          -9
   -1.019002=    -8152019/     8000000

   -3.350877=        -191/          57
   -3.350877=  -335087719*10^          -8
   -3.350877=  -335087719/   100000000

   -1.079254=        -463/         429
   -1.079254= -1079254079*10^          -9
   -1.079254= -1079254079/  1000000000

    0.719512=         354/         492
    0.719512=   719512195*10^          -9
    0.719512=   143902439/   200000000

   -0.583845=        -571/         978
   -0.583845=  -583844580*10^          -9
   -0.583845=   -29192229/    50000000

   -1.239075=        -482/         389
   -1.239075= -1239074550*10^          -9
   -1.239075=   -24781491/    20000000

  125.250000=         501/           4
  125.250000=       12525*10^          -2
  125.250000=         501/           4

DEC_TO_S_test():
  DEC_TO_S prints a decimal value.

  Mantissa  Exponent  String

       523        -1  52.3
       134         2  13400
      -134         2  -13400
         0        10  0
    123456        -8  0.00123456
    123456        -7  0.0123456
    123456        -6  0.123456
    123456        -5  1.23456
    123456        -4  12.3456
    123456        -3  123.456
    123456        -2  1234.56
    123456        -1  12345.6
    123456         0  123456
    123456         1  1234560
    123456         2  12345600
    123456         3  123456000

DEC_WIDTH_test():
  DEC_WIDTH determines the "width" of a decimal.

  Mantissa  Exponent  Width

       523        -1         4
       134         2         5
      -134         2         6
         0        10         1
    123456        -8        10
    123456        -7         9
    123456        -6         8
    123456        -5         7
    123456        -4         7
    123456        -3         7
    123456        -2         7
    123456        -1         7
    123456         0         6
    123456         1         7
    123456         2         8
    123456         3         9

DECMAT_DET_test():
  DECMAT_DET: determinant of a decimal matrix.


  The 123/456/789 matrix:

       1   2   3
       4   5   6
       7   8   9

  Determinant of the 123/456/789 matrix
         0 * 10**        0

  The Hilbert matrix:

             0.5   0.3333333        0.25         0.2
       0.3333333        0.25         0.2   0.1666667
            0.25         0.2   0.1666667   0.1428571
             0.2   0.1666667   0.1428571       0.125

  Determinant of the Hilbert matrix:
         5 * 10 **       -9

  The -1,2,-1 matrix:

        2   -1    0
       -1    2   -1
        0   -1    2

  Determinant of the -1,2,-1 matrix:
         4 * 10 **        0

DECMAT_PRINT_test():
  DECMAT_PRINT prints a decimal matrix.

  The Hilbert matrix:

             0.5   0.3333333        0.25
       0.3333333        0.25         0.2
            0.25         0.2   0.1666667
             0.2   0.1666667   0.1428571

DERANGE_ENUM_test():
  DERANGE_ENUM counts derangements;

  N    # of derangements

         0           1
         1           0
         2           1
         3           2
         4           9
         5          44
         6         265
         7        1854
         8       14833
         9      133496
        10     1334961

DERANGE_ENUM2_test():
  DERANGE_ENUM2 counts derangements.

  N    # of derangements

         0           1
         1           0
         2           1
         3           2
         4           9
         5          44
         6         265
         7        1854
         8       14833
         9      133496
        10     1334961

DERANGE_ENUM3_test():
  DERANGE_ENUM3 counts derangements.

  N    # of derangements

         0           1
         1           0
         2           1
         3           2
         4           9
         5          44
         6         265
         7        1854
         8       14833
         9      133496
        10     1334961

DERANGE1_BACK_NEXT_test():
  DERANGE1_BACK_NEXT generates derangements
  using backtracking.

  Here, we seek all derangments of order N =        5

     1       5   4   2   3   1
     2       5   4   2   1   3
     3       5   4   1   3   2
     4       5   4   1   2   3
     5       5   3   4   2   1
     6       5   3   4   1   2
     7       5   3   2   1   4
     8       5   3   1   2   4
     9       5   1   4   3   2
    10       5   1   4   2   3
    11       5   1   2   3   4
    12       4   5   2   3   1
    13       4   5   2   1   3
    14       4   5   1   3   2
    15       4   5   1   2   3
    16       4   3   5   2   1
    17       4   3   5   1   2
    18       4   3   2   5   1
    19       4   3   1   5   2
    20       4   1   5   3   2
    21       4   1   5   2   3
    22       4   1   2   5   3
    23       3   5   4   2   1
    24       3   5   4   1   2
    25       3   5   2   1   4
    26       3   5   1   2   4
    27       3   4   5   2   1
    28       3   4   5   1   2
    29       3   4   2   5   1
    30       3   4   1   5   2
    31       3   1   5   2   4
    32       3   1   4   5   2
    33       3   1   2   5   4
    34       2   5   4   3   1
    35       2   5   4   1   3
    36       2   5   1   3   4
    37       2   4   5   3   1
    38       2   4   5   1   3
    39       2   4   1   5   3
    40       2   3   5   1   4
    41       2   3   4   5   1
    42       2   3   1   5   4
    43       2   1   5   3   4
    44       2   1   4   5   3

DERANGE1_CHECK_test():
  DERANGE1_CHECK_checks whether a vector of N objects
  represents a derangement of (1,...,N).
 
  Potential derangement:
           2           3           4           5           1
  CHECK = T
 
  Potential derangement:
           2           5           3           1           4
  CHECK = F
 
  Potential derangement:
           2           3           4           1           4
  CHECK = F
 
  Potential derangement:
           0           3           4           5           1
  CHECK = F
 
  Potential derangement:
           1           4           9           2           3
  CHECK = F

DERANGE1_WEED_NEXT_test():
  DERANGE1_WEED_NEXT generates derangements of (1,...,N)
  by generating ALL permutations, and "weeding out"
  the ones that are not derangements.

  Here, we seek all derangements of order N =        5

     1       2   1   4   5   3
     2       2   1   5   3   4
     3       2   3   1   5   4
     4       2   3   4   5   1
     5       2   3   5   1   4
     6       2   4   1   5   3
     7       2   4   5   1   3
     8       2   4   5   3   1
     9       2   5   1   3   4
    10       2   5   4   1   3
    11       2   5   4   3   1
    12       3   1   2   5   4
    13       3   1   4   5   2
    14       3   1   5   2   4
    15       3   4   1   5   2
    16       3   4   2   5   1
    17       3   4   5   1   2
    18       3   4   5   2   1
    19       3   5   1   2   4
    20       3   5   2   1   4
    21       3   5   4   1   2
    22       3   5   4   2   1
    23       4   1   2   5   3
    24       4   1   5   2   3
    25       4   1   5   3   2
    26       4   3   1   5   2
    27       4   3   2   5   1
    28       4   3   5   1   2
    29       4   3   5   2   1
    30       4   5   1   2   3
    31       4   5   1   3   2
    32       4   5   2   1   3
    33       4   5   2   3   1
    34       5   1   2   3   4
    35       5   1   4   2   3
    36       5   1   4   3   2
    37       5   3   1   2   4
    38       5   3   2   1   4
    39       5   3   4   1   2
    40       5   3   4   2   1
    41       5   4   1   2   3
    42       5   4   1   3   2
    43       5   4   2   1   3
    44       5   4   2   3   1

DIGRAPH_ARC_EULER_test():
  DIGRAPH_ARC_EULER finds an Euler circuit of a digraph.

  The arc list of the digraph:

       1           2       5
       2           1       4
       3           2       3
       4           1       2
       5           3       1
       6           5       1
       7           4       2

  The edge list of the Euler circuit:

       1         6
       2         4
       3         3
       4         5
       5         2
       6         7
       7         1

  The node list of the Euler circuit:

    I  Edge  Node

         1       6       1
         2       4       2
         3       3       3
         4       5       1
         5       2       4
         6       7       2
         7       1       5

DIGRAPH_ARC_PRINT_test():
  DIGRAPH_ARC_PRINT prints a digraph.

  The arc list of the digraph:

       1           2       5
       2           1       4
       3           2       3
       4           1       2
       5           3       1
       6           5       1
       7           4       2

DIOPHANTINE_test():
  DIOPHANTINE solves a Diophantine equation:
    A * X + B * Y = C

        A         B         C         X     Y     Error

        1027       712         7       269      -388         0
        1027       712        -7      -269       388         0
        1027      -712         7       269       388         0
        1027      -712        -7      -269      -388         0
       -1027       712         7      -269      -388         0
       -1027       712        -7       269       388         0
       -1027      -712         7      -269       388         0
       -1027      -712        -7       269      -388         0
           6         8        50         3         4         0
           0         0         0         0         0         0
           0         1         0         0         0         0
           0         1         1         0         1         0
           1         0         0         0         0         0
           1         0         1         1         0         0
           1         1         0         1        -1         0
        1024    -15625     11529        -4        -1         0
           0         0         1 Error code =          1
           0         3        11 Error code =          2
           5         0        19 Error code =          3
           2         4         7 Error code =          4

DIOPHANTINE_SOLUTION_MINIMIZE_test():
  DIOPHANTINE_SOLUTION_MINIMIZE computes a minimal
  Euclidean norm solution of a Diophantine equation:
    A * X + B * Y = C

  Coefficients:
    A =         4096
    B =       -15625
    C =        46116
  Solution:
    X =    665499996
    Y =    174456828
  Residual R = A * X + B * Y - C:
    R =            0

  The minimized solution:
    X =           -4
    Y =           -4
  Residual R = A * X + B * Y - C:
    R =            0

  The minimal positive solution:
    X =        15621
    Y =         4092
  Residual R = A * X + B * Y - C:
    R =            0

dvec_add_test():
  dvec_add() adds decimal vectors representing integers;

        I        J        K = I + J


        98       -48
  Directly:                 50
            DVEC_ADD        50

       -34        10
  Directly:                -24
            DVEC_ADD       -24

        98        38
  Directly:                136
            DVEC_ADD       136

        47        57
  Directly:                104
            DVEC_ADD       104

       -46        99
  Directly:                 53
            DVEC_ADD        53

        75       -41
  Directly:                 34
            DVEC_ADD        34

       -78         7
  Directly:                -71
            DVEC_ADD       -71

       -41       -86
  Directly:               -127
            DVEC_ADD      -127

       -59       -35
  Directly:                -94
            DVEC_ADD       -94

        44        68
  Directly:                112
            DVEC_ADD       112

DVEC_COMPLEMENTX_test():
  DVEC_COMPLEMENTX returns the ten's complement
  of a (signed) decimal vector;


  I =          7
  J =         -7

  +000000007

  -999999993

  I =         53
  J =        -53

  +000000053

  -999999947

  I =         30
  J =        -30

  +000000030

  -999999970

  I =        -61
  J =         61

  -999999939

  +000000061

  I =         26
  J =        -26

  +000000026

  -999999974

DVEC_MUL_test():
  DVEC_MUL multiplies decimal vectors 
  representing integers;

        I        J        K = I * J


       246      -672
  Directly:            -165312
  DVEC_MUL             -165312

       -57       700
  Directly:             -39900
  DVEC_MUL              -39900

      -910         5
  Directly:              -4550
  DVEC_MUL               -4550

       830      -175
  Directly:            -145250
  DVEC_MUL             -145250

        13      -165
  Directly:              -2145
  DVEC_MUL               -2145

      -387      -253
  Directly:              97911
  DVEC_MUL               97911

       984      -339
  Directly:            -333576
  DVEC_MUL             -333576

       519       947
  Directly:             491493
  DVEC_MUL              491493

       959      -834
  Directly:            -799806
  DVEC_MUL             -799806

      -520       787
  Directly:            -409240
  DVEC_MUL             -409240

  NOW REPEAT THE TEST...

  but use too few digits to represent big products.
  This corresponds to an "overflow".
  The result here should get the final decimal
  digits correctly, though.

        I        J        K = I * J


       265      -987
  Directly:            -261555
  DVEC_MUL              -61555

       423      -398
  Directly:            -168354
  DVEC_MUL              -68354

      -602      -223
  Directly:             134246
  DVEC_MUL               34246

       696       561
  Directly:             390456
  DVEC_MUL               90456

       310       104
  Directly:              32240
  DVEC_MUL               32240

      -430       734
  Directly:            -315620
  DVEC_MUL              -15620

      -193       338
  Directly:             -65234
  DVEC_MUL              -65234

       146       957
  Directly:             139722
  DVEC_MUL               39722

      -544       358
  Directly:            -194752
  DVEC_MUL              -94752

       550       -39
  Directly:             -21450
  DVEC_MUL              -21450

DVEC_PRINT_test():
  DVEC_PRINT prints a (signed) decimal vector;

  The DVEC:

  -0055771439876543210

DVEC_SUB_test():
  DVEC_SUB subtracts decimal vectors representing integers;

        I        J        L = I - J


       -91       -98
  Directly:                  7
            DVEC_SUB         7

        52       -89
  Directly:                141
            DVEC_SUB       141

       -19       -62
  Directly:                 43
            DVEC_SUB        43

       -68        65
  Directly:               -133
            DVEC_SUB      -133

       -71       -97
  Directly:                 26
            DVEC_SUB        26

        76        49
  Directly:                 27
            DVEC_SUB        27

        44        41
  Directly:                  3
            DVEC_SUB         3

        98        71
  Directly:                 27
            DVEC_SUB        27

        73        99
  Directly:                -26
            DVEC_SUB       -26

       -26       -48
  Directly:                 22
            DVEC_SUB        22

DVEC_TO_I4_test():
  DVEC_TO_I4 converts a DVEC to an I4

        I4 => DVEC => I4

   -2063   9 9 7 9 3 7   -2063

EQUIV_NEXT_test():
  EQUIV_NEXT generates all partitions of a set.

  Rank/element:   1   2   3   4

     1   1   1   1   1
     2   1   1   1   2
     3   1   1   2   1
     4   1   1   2   2
     5   1   1   2   3
     6   1   2   1   1
     7   1   2   1   2
     8   1   2   1   3
     9   1   2   2   1
    10   1   2   2   2
    11   1   2   2   3
    12   1   2   3   1
    13   1   2   3   2
    14   1   2   3   3
    15   1   2   3   4

EQUIV_NEXT2_test():
  EQUIV_NEXT2 generates all partitions of a set.
  Here, N =        4

  Rank/element:   1   2   3   4

     1             1   1   1   1
     2             1   1   1   2
     3             1   1   2   1
     4             1   1   2   2
     5             1   1   2   3
     6             1   2   1   1
     7             1   2   1   2
     8             1   2   1   3
     9             1   2   2   1
    10             1   2   2   2
    11             1   2   2   3
    12             1   2   3   1
    13             1   2   3   2
    14             1   2   3   3
    15             1   2   3   4

EQUIV_PRINT_test():
  EQUIV_PRINT prints a set partition.

  The set partition:

   Set  Size
       1       2 ::    2   4
       2       1 ::    1
       3       1 ::    3

  The set partition:

   Set  Size
       1       2 ::    3   4
       2       2 ::    1   2

  The set partition:

   Set  Size
       1       1 ::    1
       2       1 ::    2
       3       1 ::    4
       4       1 ::    3

  The set partition:

   Set  Size
       1       1 ::    3
       2       3 ::    1   2   4

  The set partition:

   Set  Size
       1       3 ::    1   2   4
       2       1 ::    3

EQUIV_PRINT2_test():
  EQUIV_PRINT2 prints a set partition.

  The set partition:

( 4)( 1, 3)( 2)

  The set partition:

( 2)( 1, 3)( 4)

  The set partition:

( 1)( 2)( 3, 4)

  The set partition:

( 1, 2)( 3, 4)

  The set partition:

( 1, 2, 3, 4)

EQUIV_RANDOM_test():
  EQUIV_RANDOM selects a random set partition.

  The set partition:

( 1, 2)( 4)( 3)

  The set partition:

( 2, 3, 4)( 1)

  The set partition:

( 3, 4)( 1)( 2)

  The set partition:

( 1, 3, 4)( 2)

  The set partition:

( 4)( 2)( 1, 3)

EULER_ROW_test():
  EULER_ROW gets rows of Euler's triangle.

        1
        1      0
        1      1      0
        1      4      1      0
        1     11     11      1      0
        1     26     66     26      1      0
        1     57    302    302     57      1      0
        1    120   1191   2416   1191    120      1      0
        1    247   4293  15619  15619   4293    247      1      0
        1    502  14608  88234 156190  88234  14608    502      1      0

FROBENIUS_NUMBER_ORDER2_test():
  FROBENIUS_NUMBER_ORDER2 computes Frobenius numbers of order 2.

        C1        C1   exact F  comput F

         2         5         3         3
         3        17        31        31
         4        19        23        53
         5        13        47        47
        12        11       109       109
        99       100      9701      9701

GRAY_NEXT_test():
  GRAY_NEXT returns the index of the single item
  to be changed in order to get the next Gray code.

   K  Change  Gray Code

   1         0  0000
   2         1  1000
   3         2  1100
   4        -1  0100
   5         3  0110
   6         1  1110
   7        -2  1010
   8        -1  0010
   9         4  0011
  10         1  1011
  11         2  1111
  12        -1  0111
  13        -3  0101
  14         1  1101
  15        -2  1001
  16        -1  0001

GRAY_RANK1_test():
  GRAY_RANK1 ranks a Gray code;

    R  =                         RANK
    G  =            GRAY_UNRANK1(RANK)
    R2 = GRAY_RANK1(GRAY_UNRANK1(RANK))

         R         G         R2

         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24

GRAY_RANK2_test():
  GRAY_RANK2 ranks a Gray code;

    R  =                         RANK
    G  =            GRAY_UNRANK2(RANK)
    R2 = GRAY_RANK2(GRAY_UNRANK2(RANK))

         R         G         R2

         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24

GRAY_UNRANK1_test():
  GRAY_UNRANK1 unranks a Gray code.

    R  =                         RANK
    G  =            GRAY_UNRANK1(RANK)
    R2 = GRAY_RANK1(GRAY_UNRANK1(RANK))

         R         G         R2

         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24

GRAY_UNRANK2_test():
  GRAY_UNRANK2 unranks a Gray code.

    R  =                         RANK
    G  =            GRAY_UNRANK2(RANK)
    R2 = GRAY_RANK2(GRAY_UNRANK2(RANK))

         R         G         R2

         0         0         0
         1         1         1
         2         3         2
         3         2         3
         4         6         4
         5         7         5
         6         5         6
         7         4         7
         8        12         8
         9        13         9
        10        15        10
        11        14        11
        12        10        12
        13        11        13
        14         9        14
        15         8        15
        16        24        16
        17        25        17
        18        27        18
        19        26        19
        20        30        20
        21        31        21
        22        29        22
        23        28        23
        24        20        24
 
I4_BCLR_test():
  I4_BCLR sets a given bit to 0.
 
  Working on I4 =      101
 
       Pos     I4_BCLR(I4,POS)
 
         0           100
         1           101
         2            97
         3           101
         4           101
         5            69
         6            37
         7           101
         8           101
         9           101
        10           101
        11           101
        12           101
        13           101
        14           101
        15           101
        16           101
        17           101
        18           101
        19           101
        20           101
        21           101
        22           101
        23           101
        24           101
        25           101
        26           101
        27           101
        28           101
        29           101
        30           101
        31           101
 
  Working on I4 =      -31
 
       Pos     I4_BCLR(I4,POS)
 
         0           -32
         1           -31
         2           -31
         3           -31
         4           -31
         5           -63
         6           -95
         7          -159
         8          -287
         9          -543
        10         -1055
        11         -2079
        12         -4127
        13         -8223
        14        -16415
        15        -32799
        16        -65567
        17       -131103
        18       -262175
        19       -524319
        20      -1048607
        21      -2097183
        22      -4194335
        23      -8388639
        24     -16777247
        25     -33554463
        26     -67108895
        27    -134217759
        28    -268435487
        29    -536870943
        30   -1073741855
        31    2147483617
 
I4_BSET_test():
  I4_BSET sets a given bit to 1.
 
  Working on I4 =      101
 
       Pos     I4_BSET(I4,POS)
 
         0           101
         1           103
         2           101
         3           109
         4           117
         5           101
         6           101
         7           229
         8           357
         9           613
        10          1125
        11          2149
        12          4197
        13          8293
        14         16485
        15         32869
        16         65637
        17        131173
        18        262245
        19        524389
        20       1048677
        21       2097253
        22       4194405
        23       8388709
        24      16777317
        25      33554533
        26      67108965
        27     134217829
        28     268435557
        29     536871013
        30    1073741925
        31   -2147483547
 
  Working on I4 =      -31
 
       Pos     I4_BSET(I4,POS)
 
         0           -31
         1           -29
         2           -27
         3           -23
         4           -15
         5           -31
         6           -31
         7           -31
         8           -31
         9           -31
        10           -31
        11           -31
        12           -31
        13           -31
        14           -31
        15           -31
        16           -31
        17           -31
        18           -31
        19           -31
        20           -31
        21           -31
        22           -31
        23           -31
        24           -31
        25           -31
        26           -31
        27           -31
        28           -31
        29           -31
        30           -31
        31           -31
 
I4_BTEST_test():
  I4_BTEST reports whether a given bit is 0 or 1.
 
  Analyze the integer I4 =      101
 
       Pos     I4_BTEST(I4,POS)
 
         0             T
         1             F
         2             T
         3             F
         4             F
         5             T
         6             T
         7             F
         8             F
         9             F
        10             F
        11             F
        12             F
        13             F
        14             F
        15             F
        16             F
        17             F
        18             F
        19             F
        20             F
        21             F
        22             F
        23             F
        24             F
        25             F
        26             F
        27             F
        28             F
        29             F
        30             F
        31             F
 
  Analyze the integer I4 =      -31
 
       Pos     I4_BTEST(I4,POS)
 
         0             T
         1             F
         2             F
         3             F
         4             F
         5             T
         6             T
         7             T
         8             T
         9             T
        10             T
        11             T
        12             T
        13             T
        14             T
        15             T
        16             T
        17             T
        18             T
        19             T
        20             T
        21             T
        22             T
        23             T
        24             T
        25             T
        26             T
        27             T
        28             T
        29             T
        30             T
        31             T

I4_CHOOSE_test():
  I4_CHOOSE evaluates C(N,K).

         N         K       CNK

         0         0         1

         1         0         1
         1         1         1

         2         0         1
         2         1         2
         2         2         1

         3         0         1
         3         1         3
         3         2         3
         3         3         1

         4         0         1
         4         1         4
         4         2         6
         4         3         4
         4         4         1

I4_FACTOR_test():
  I4_FACTOR factors an integer,

  The integer is     2516

  Prime representation:

         I  FACTOR(I)  POWER(I)

         1       2       2
         2      17       1
         3      37       1

I4_FALL_TEST:
  I4_FALL evaluates the falling factorial function:

         M         N      Exact         I4_FALL(M,N)

         5         0             1             1
         5         1             5             5
         5         2            20            20
         5         3            60            60
         5         4           120           120
         5         5           120           120
         5         6             0             0
        50         0             1             1
        10         1            10            10
      4000         1          4000          4000
        10         2            90            90
        18         3          4896          4896
         4         4            24            24
        98         3        912576        912576
         1         7             0             0

I4_GCD_test():
  I4_GCD computes the greatest common divisor
  of two integers.

         I       J    I4_GCD(I,J)

         5      14       1
         3       2       1
         4       9       1
         6      13       1
         5      15       5
        -1      11       1
        11       5       1
         8      14       2
         2       8       2
         4      12       4
        -2      10       2
         8       5       1
        12      12      12
        15       7       1
        -2       8       2
 
i4_gpf_test():
  i4_gpf() returns the greatest prime factor:
 
         n      gpf(n)    i4_gpf(n)
 
         1             1             1
         2             2             2
         3             3             3
         4             2             2
         5             5             5
         6             3             3
         7             7             7
         8             2             2
         9             3             3
        10             5             5
        11            11            11
        12             3             3
        13            13            13
        14             7             7
        15             5             5
        16             2             2
        17            17            17
        18             3             3
        19            19            19
        20             5             5
        21             7             7
        22            11            11
        23            23            23
        24             3             3
        25             5             5
        26            13            13
        27             3             3
        28             7             7
        29            29            29
        30             5             5
        31            31            31
        32             2             2
        33            11            11
        34            17            17
        35             7             7
        36             3             3
        37            37            37
        38            19            19
        39            13            13
        40             5             5
        41            41            41
        42             7             7
        43            43            43
        44            11            11
        45             5             5
        46            23            23
        47            47            47
        48             3             3
        49             7             7
        50             5             5
        51            17            17
        52            13            13
        53            53            53
        54             3             3
        55            11            11
        56             7             7
        57            19            19
        58            29            29
        59            59            59
        60             5             5
        61            61            61
        62            31            31
        63             7             7
        64             2             2
        65            13            13
        66            11            11
        67            67            67
        68            17            17
        69            23            23
        70             7             7
        71            71            71
        72             3             3
        73            73            73
        74            37            37
        75             5             5
        76            19            19
        77            11            11
        78            13            13
        79            79            79
        80             5             5
        81             3             3
        82            41            41
        83            83            83
        84             7             7
        85            17            17
        86            43            43
 
I4_HUGE_test():
  I4_HUGE returns a huge integer.
 
  I4_HUGE() =   2147483647
  HUGE(1) =     2147483647

I4_LOG_10_test():
  I4_LOG_10: whole part of log base 10,

         X        I4_LOG_10

         0           0
         1           0
         2           0
         3           0
         9           0
        10           1
        11           1
        99           1
       100           2
       101           2
       999           2
      1000           3
      1001           3
        -1           0
        -2           0
        -3           0
        -9           0
       -10           1
       -11           1
       -99           1
      -101           2
 
I4_MODP_test():
  I4_MODP factors a number
  into a multiple and a positive remainder.
 
    Number   Divisor  Multiple Remainder
 
         107        50         2         7
         107       -50        -2         7
        -107        50        -3        43
        -107       -50         3        43
 
  Repeat using FORTRAN MOD:
 
         107        50         2         7
         107       -50        -2         7
        -107        50        -2        -7
        -107       -50         2        -7

I4_MOEBIUS_TEST:
  I4_MOEBIUS evaluates the Moebius function:

         N      Exact         I4_MOEBIUS(N)

         1             1             1
         2            -1            -1
         3            -1            -1
         4             0             0
         5            -1            -1
         6             1             1
         7            -1            -1
         8             0             0
         9             0             0
        10             1             1
        11            -1            -1
        12             0             0
        13            -1            -1
        14             1             1
        15             1             1
        16             0             0
        17            -1            -1
        18             0             0
        19            -1            -1
        20             0             0

I4_PARTITION_CONJ_test():
  I4_PARTITION_CONJ conjugates an integer partition.

  Original partition:

  14 = 1 * 2 + 1 * 5 + 3 * 1 + 1 * 4

  Conjugate partition:

  14 = 1 * 6 + 1 * 3 + 2 * 2 + 1 * 1

I4_PARTITION_COUNT_test():
  I4_PARTITION_COUNT counts partitions of an integer.

   N     Exact     Count

     0         1         1
     1         1         1
     2         2         2
     3         3         3
     4         5         5
     5         7         7
     6        11        11
     7        15        15
     8        22        22
     9        30        30
    10        42        42
    11        56        56
    12        77        77
    13       101       101
    14       135       135
    15       176       176
    16       231       231
    17       297       297
    18       385       385
    19       490       490
    20       627       627

I4_PARTITION_COUNT2_test():
  I4_PARTITION_COUNT2 counts partitions of an integer.

   N     Exact     Count

     0         1         1
     1         1         1
     2         2         2
     3         3         3
     4         5         5
     5         7         7
     6        11        11
     7        15        15
     8        22        22
     9        30        30
    10        42        42
    11        56        56
    12        77        77
    13       101       101
    14       135       135
    15       176       176
    16       231       231
    17       297       297
    18       385       385
    19       490       490
    20       627       627

I4_PARTITION_NEXT_test():
  I4_PARTITION_NEXT generates partitions of an integer.
  Here N =        7

  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1

I4_PARTITION_NEXT2_test():
  I4_PARTITION_NEXT2 produces partitions of an integer.

  7 = 1 * 7
  7 = 1 * 6 + 1 * 1
  7 = 1 * 5 + 1 * 2
  7 = 1 * 5 + 2 * 1
  7 = 1 * 4 + 1 * 3
  7 = 1 * 4 + 1 * 2 + 1 * 1
  7 = 1 * 4 + 3 * 1
  7 = 2 * 3 + 1 * 1
  7 = 1 * 3 + 2 * 2
  7 = 1 * 3 + 1 * 2 + 2 * 1
  7 = 1 * 3 + 4 * 1
  7 = 3 * 2 + 1 * 1
  7 = 2 * 2 + 3 * 1
  7 = 1 * 2 + 5 * 1
  7 = 7 * 1

I4_PARTITION_PRINT_test():
  I4_PARTITION_PRINT prints an integer partition.

  14 = 1 * 2 + 1 * 5 + 3 * 1 + 1 * 4

I4_PARTITION_RANDOM_test():
  I4_PARTITION_RANDOM generates a random partition.


  The number of partitions of N

       N    Number of partitions

         0           1
         1           1
         2           2
         3           3
         4           5
         5           7
         6          11
         7          15
         8          22

  8 = 2 * 1 + 3 * 2
  8 = 2 * 4
  8 = 8 * 1
  8 = 3 * 1 + 1 * 5
  8 = 1 * 1 + 1 * 2 + 1 * 5

I4_PARTITIONS_NEXT_test():
  I4_PARTITIONS_NEXT produces the next
  nondecreasing partitions of an integer, and
  if necessary, increments the integer to keep on going.

   I Sum    Partition

   0   0     0 0 0
   1   1     1 0 0
   2   2     2 0 0
   3   2     1 1 0
   4   3     3 0 0
   5   3     2 1 0
   6   3     1 1 1
   7   4     4 0 0
   8   4     3 1 0
   9   4     2 2 0
  10   4     2 1 1
  11   5     5 0 0
  12   5     4 1 0
  13   5     3 2 0
  14   5     3 1 1
  15   5     2 2 1

  You can start from any legal partition.
  Here, we restart at ( 2, 1, 0 ).

   I Sum    Partition

   0   3     2 1 0
   1   3     1 1 1
   2   4     4 0 0
   3   4     3 1 0
   4   4     2 2 0
   5   4     2 1 1
   6   5     5 0 0
   7   5     4 1 0
   8   5     3 2 0
   9   5     3 1 1
  10   5     2 2 1
  11   6     6 0 0
  12   6     5 1 0
  13   6     4 2 0
  14   6     3 3 0
  15   6     4 1 1

I4_RISE_TEST:
  I4_RISE evaluates the rising factorial function:

         M         N      Exact         I4_RISE(M,N)

         5         0             1             1
         5         1             5             5
         5         2            30            30
         5         3           210           210
         5         4          1680          1680
         5         5         15120         15120
         5         6        151200        151200
        50         0             1             1
        10         1            10            10
      4000         1          4000          4000
        10         2           110           110
        18         3          6840          6840
         4         4           840           840
        98         3        970200        970200
         1         7          5040          5040

I4_SQRT_test():
  I4_SQRT computes the square root of an integer.

       N  Sqrt(N) Remainder

         -5        2        1
         -4        2        0
         -3        1        2
         -2        1        1
         -1        1        0
          0        0        0
          1        1        0
          2        1        1
          3        1        2
          4        2        0
          5        2        1
          6        2        2
          7        2        3
          8        2        4
          9        3        0
         10        3        1
         11        3        2
         12        3        3
         13        3        4
         14        3        5
         15        3        6
         16        4        0
         17        4        1
         18        4        2
         19        4        3
         20        4        4

I4_SQRT_CF_test():
  I4_SQRT_CF computes the continued fraction form
  of the square root of an integer.

   N  Period  Whole  Repeating Part

      1       0      1
      2       1      1    2
      3       2      1    1    2
      4       0      2
      5       1      2    4
      6       2      2    2    4
      7       4      2    1    1    1    4
      8       2      2    1    4
      9       0      3
     10       1      3    6
     11       2      3    3    6
     12       2      3    2    6
     13       5      3    1    1    1    1    6
     14       4      3    1    2    1    6
     15       2      3    1    6
     16       0      4
     17       1      4    8
     18       2      4    4    8
     19       6      4    2    1    3    1    2    8
     20       2      4    2    8

I4_TO_CHINESE_test():
  I4_TO_CHINESE computes the Chinese Remainder
  representation of an integer.

  The moduli:

       1         3
       2         4
       3         5
       4         7

  The number being analyzed is       37

  The remainders:

       1         1
       2         1
       3         2
       4         2

  The reconstructed number is       37

  The remainders of the reconstructed number are:

       1         1
       2         1
       3         2
       4         2

I4_TO_DVEC_test():
  I4_TO_DVEC converts a DVEC to an I4

        I4 => DVEC => I4

   -4037   9 9 5 9 6 3   -4037

I4_TO_I4POLY_test():
  I4_TO_I4POLY converts an integer to a polynomial
  in a given base;

       I    BASE  DEGREE  Coefficients

     1     2     0             1
     6     2     2             1       1       0
    23     2     4             1       0       1       1       1
    23     3     2             2       1       2
    23     4     2             1       1       3
    23     5     1             4       3
    23     6     1             3       5
    23    23     1             1       0
    23    24     0            23

  Now let I4_TO_I4POLY convert I to a polynomial,
  use I4POLY_TO_I4 to evaluate it, and compare.

       I    I2

         1         1
         6         6
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23

I4MAT_01_ROWCOLSUM_test():
  I4MAT_01_ROWCOLSUM constructs a 01 matrix with
  given row and column sums.

  The rowsum vector R:

       1        14
       2        13
       3        14
       4        10
       5        12
       6         2
       7        10
       8         1
       9        10
      10        11
      11         6
      12         2
      13        17

  The columnsum vector C:

       1         4
       2         4
       3        11
       4        10
       5        10
       6         8
       7         9
       8        10
       9         8
      10         9
      11         3
      12        10
      13         4
      14         7
      15         9
      16         3
      17         3

  The rowcolsum matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        0      1      1      1      1      1      1      1      1      1
       2        1      0      1      1      1      0      1      1      1      1
       3        1      0      1      1      1      1      1      1      0      1
       4        0      0      1      0      1      1      1      1      1      1
       5        1      1      1      1      1      1      1      1      1      1
       6        0      0      0      1      1      0      0      0      0      0
       7        0      0      1      1      0      1      1      1      1      1
       8        0      0      0      1      0      0      0      0      0      0
       9        0      0      1      1      0      1      1      1      1      1
      10        0      1      1      1      1      1      1      1      1      0
      11        0      0      1      0      1      0      0      1      0      1
      12        0      0      1      0      1      0      0      0      0      0
      13        1      1      1      1      1      1      1      1      1      1

  Col        11     12     13     14     15     16     17
  Row

       1        1      1      1      0      1      1      0
       2        0      1      1      1      1      0      1
       3        0      1      1      1      1      1      1
       4        0      1      0      1      1      0      0
       5        0      1      0      1      0      0      0
       6        0      0      0      0      0      0      0
       7        0      1      0      1      1      0      0
       8        0      0      0      0      0      0      0
       9        0      1      0      1      1      0      0
      10        0      1      0      1      1      0      0
      11        0      1      0      0      1      0      0
      12        0      0      0      0      0      0      0
      13        2      1      1      0      1      1      1

  Computed row sums

       1        14
       2        13
       3        14
       4        10
       5        12
       6         2
       7        10
       8         1
       9        10
      10        11
      11         6
      12         2
      13        17

  Computed column sums:

       1         4
       2         4
       3        11
       4        10
       5        10
       6         8
       7         9
       8        10
       9         8
      10         9
      11         3
      12        10
      13         4
      14         7
      15         9
      16         3
      17         3

I4MAT_01_ROWCOLSUM2_test():
  I4MAT_01_ROWCOLSUM2 constructs a 01 matrix with
  given row and column sums.

  The rowsum vector:

       1         2
       2         1
       3         3
       4         1
       5         2

  The columnsum vector:

       1         2
       2         1
       3         2
       4         2
       5         2

  The rowcolsum matrix:

  Col         1      2      3      4      5
  Row

       1        0      0      1      1      0
       2        0      0      0      1      0
       3        0      1      1      0      1
       4        1      0      0      0      0
       5        1      0      0      0      1

  Now repeat, with data for which there is not
  a solution.  The program will try its best anyway.

  The rowsum vector:

       1         1
       2         3
       3         4
       4         1
       5         3

  The columnsum vector:

       1         1
       2         4
       3         1
       4         5
       5         1

  I4MAT_01_ROWCOLSUM2 returned error flag IERROR =        1
  The matrix returned is not an exact solution.

  The rowcolsum matrix:

  Col         1      2      3      4      5
  Row

       1        0      0      0      1      0
       2        0      1      1      1      0
       3        1      1      0      1      1
       4        0      1      0      1     -1
       5        0      1      0      1      1

I4MAT_U1_INVERSE_test():
  I4MAT_U1_INVERSE inverts a unit upper triangular matrix.

  The input matrix:

  Col         1      2      3      4      5      6
  Row

       1        1      1      0      0      0     75
       2        0      1      0      0      0      0
       3        0      0      1      1      0      0
       4        0      0      0      1      0      0
       5        0      0      0      0      1      1
       6        0      0      0      0      0      1

  The inverse:

  Col         1      2      3      4      5      6
  Row

       1        1     -1      0      0      0    -75
       2        0      1      0      0      0      0
       3        0      0      1     -1      0      0
       4        0      0      0      1      0      0
       5        0      0      0      0      1     -1
       6        0      0      0      0      0      1

I4MAT_PERM1_test():
  I4MAT_PERM1 reorders an integer matrix in place.
  The rows and columns use the same permutation.

  The input matrix:

  Col         1      2      3      4      5      6      7      8      9
  Row

       1       11     12     13     14     15     16     17     18     19
       2       21     22     23     24     25     26     27     28     29
       3       31     32     33     34     35     36     37     38     39
       4       41     42     43     44     45     46     47     48     49
       5       51     52     53     54     55     56     57     58     59
       6       61     62     63     64     65     66     67     68     69
       7       71     72     73     74     75     76     77     78     79
       8       81     82     83     84     85     86     87     88     89
       9       91     92     93     94     95     96     97     98     99

  The row and column permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permuted matrix:

  Col         1      2      3      4      5      6      7      8      9
  Row

       1       99     91     92     98     97     94     95     96     93
       2       19     11     12     18     17     14     15     16     13
       3       29     21     22     28     27     24     25     26     23
       4       89     81     82     88     87     84     85     86     83
       5       79     71     72     78     77     74     75     76     73
       6       49     41     42     48     47     44     45     46     43
       7       59     51     52     58     57     54     55     56     53
       8       69     61     62     68     67     64     65     66     63
       9       39     31     32     38     37     34     35     36     33

I4MAT_2PERM1_test():
  I4MAT_2PERM1 reorders an integer matrix in place.
  Rows and columns use different permutations.

  The input matrix:

  Col         1      2      3      4      5      6      7
  Row

       1       11     12     13     14     15     16     17
       2       21     22     23     24     25     26     27
       3       31     32     33     34     35     36     37
       4       41     42     43     44     45     46     47
       5       51     52     53     54     55     56     57
       6       61     62     63     64     65     66     67
       7       71     72     73     74     75     76     77
       8       81     82     83     84     85     86     87
       9       91     92     93     94     95     96     97

  The row permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The column permutation:

     1   2   3   4   5   6   7
     3   4   5   6   7   1   2

  The permuted matrix:

  Col         1      2      3      4      5      6      7
  Row

       1       96     97     91     92     93     94     95
       2       16     17     11     12     13     14     15
       3       26     27     21     22     23     24     25
       4       86     87     81     82     83     84     85
       5       76     77     71     72     73     74     75
       6       46     47     41     42     43     44     45
       7       56     57     51     52     53     54     55
       8       66     67     61     62     63     64     65
       9       36     37     31     32     33     34     35

I4POLY_test():
  I4POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial

  All calls have input A as follows
   0   0   0   0   0   1

  Option IOPT =       -3
  Output array = 
     0  24 -50  35 -10   1

  Option IOPT =       -2
  Output array = 
     0   1  15  25  10   1

  Option IOPT =       -1
  X0 =        2
  Value =        0

  Option IOPT =        0
  X0 =        2
  Value =       32

  Option IOPT =        6
  X0 =        2
  Output array = 
    32  80  80  40  10   1

  Option IOPT =        6
  X0 =       -2
  Output array = 
   -32  80 -80  40 -10   1

I4POLY_ADD_test():
  I4POLY_ADD adds two I4POLY's.

  Polynomial A:

  p(x) =         5 * x ^   5
         +       4 * x ^   4
         +       3 * x ^   3
         +       2 * x ^   2
         +       1 * x

  Polynomial B:

  p(x) = -       5 * x ^   5
         +       8 * x ^   3
         +       7 * x ^   2
         -       2 * x
         +       1

  Polynomial C = A+B:

  p(x) =         4 * x ^   4
         +      11 * x ^   3
         +       9 * x ^   2
         -       1 * x
         +       1

I4POLY_CYCLO_test():
  I4POLY_CYCLO computes cyclotomic polynomials.

  N =        0


  The cyclotomic polynomial:

  p(x) =         1

  N =        1


  The cyclotomic polynomial:

  p(x) =         1 * x
         -       1

  N =        2


  The cyclotomic polynomial:

  p(x) =         1 * x
         +       1

  N =        3


  The cyclotomic polynomial:

  p(x) =         1 * x ^   2
         +       1 * x
         +       1

  N =        4


  The cyclotomic polynomial:

  p(x) =         1 * x ^   2
         +       1

  N =        5


  The cyclotomic polynomial:

  p(x) =         1 * x ^   4
         +       1 * x ^   3
         +       1 * x ^   2
         +       1 * x
         +       1

  N =        6


  The cyclotomic polynomial:

  p(x) =         1 * x ^   2
         -       1 * x
         +       1

  N =        7


  The cyclotomic polynomial:

  p(x) =         1 * x ^   6
         +       1 * x ^   5
         +       1 * x ^   4
         +       1 * x ^   3
         +       1 * x ^   2
         +       1 * x
         +       1

  N =        8


  The cyclotomic polynomial:

  p(x) =         1 * x ^   4
         +       1

  N =        9


  The cyclotomic polynomial:

  p(x) =         1 * x ^   6
         +       1 * x ^   3
         +       1

  N =       10


  The cyclotomic polynomial:

  p(x) =         1 * x ^   4
         -       1 * x ^   3
         +       1 * x ^   2
         -       1 * x
         +       1

I4POLY_DEGREE_test():
  I4POLY_DEGREE returns the degree of an I4POLY.

  The polynomial:

  p(x) =         7 * x ^   7
         +       6 * x ^   6
         +       4 * x ^   4
         +       2 * x ^   2
         +       1 * x

  The polynomial degree is    7

I4POLY_DIF_test():
  I4POLY_DIF computes derivatives of an I4POLY.


  The polynomial A:

  p(x) =         1 * x ^   3
         +       2 * x ^   2
         -       5 * x
         -       6

  Differentiate A  1 times.

  The derivative, B:

  p(x) =         3 * x ^   2
         +       4 * x
         -       5

  The polynomial A:

  p(x) =         1 * x ^   4
         +       3 * x ^   3
         +       2 * x ^   2
         +       5 * x
         -       2

  Differentiate A  3 times.

  The derivative, B:

  p(x) =        24 * x
         +      18

I4POLY_DIV_test():
  I4POLY_DIV computes the quotient and
  remainder for polynomial division.


  The polynomial to be divided, A:

  p(x) =         1 * x ^   3
         +       2 * x ^   2
         -       5 * x
         -       6

  The divisor polynomial, B:

  p(x) =         1 * x
         -       2

  The quotient polynomial, Q:

  p(x) =         1 * x ^   2
         +       4 * x
         +       3

  The remainder polynomial, R:

  p(x) =         0

  The polynomial to be divided, A:

  p(x) =         1 * x ^   4
         +       3 * x ^   3
         +       2 * x ^   2
         +       5 * x
         -       2

  The divisor polynomial, B:

  p(x) =         1 * x ^   2
         +       1 * x
         -       3

  The quotient polynomial, Q:

  p(x) =         1 * x ^   2
         +       2 * x
         +       3

  The remainder polynomial, R:

  p(x) =         8 * x
         +       7

I4POLY_MUL_test():
  I4POLY_MUL multiplies two polynomials.


  The factor A:

  p(x) =         1 * x
         +       1

  The factor B:

  p(x) = -       1 * x
         +       1

  The product C = A*B:

  p(x) = -       1 * x ^   2
         +       1

  The factor A:

  p(x) =         3 * x ^   2
         +       2 * x
         +       1

  The factor B:

  p(x) = -       2 * x
         +       1

  The product C = A*B:

  p(x) = -       6 * x ^   3
         -       1 * x ^   2
         +       1

I4POLY_PRINT_test():
  I4POLY_PRINT prints an I4POLY.

  The polynomial:

  p(x) =         1 * x ^   4
         +       3 * x ^   3
         +       2 * x ^   2
         +       5 * x
         -       2

I4POLY_TO_I4_test():
  I4POLY_TO_I4 evaluates an integer polynomial.

       I    BASE  DEGREE  Coefficients

     1     2     0             1
     6     2     2             1       1       0
    23     2     4             1       0       1       1       1
    23     3     2             2       1       2
    23     4     2             1       1       3
    23     5     1             4       3
    23     6     1             3       5
    23    23     1             1       0
    23    24     0            23

  Now let I4_TO_I4POLY convert I to a polynomial,
  use I4POLY_TO_I4 to evaluate it, and compare.

       I    I2

         1         1
         6         6
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23
        23        23

I4VEC_BACKTRACK_test():
  I4VEC_BACKTRACK uses backtracking, seeking a vector X
  of N values which satisfies some condition.

  In this demonstration, we have 8 integers W(I).
  We seek all subsets that sum to 53.
  X(I) is 0 or 1 if the entry is skipped or used.

   1      53:    15  22  16
   2      53:    15  14  16   8
   3      53:    22  14   9   8

  Done!

I4VEC_DESCENDS_test():
  I4VEC_DESCENDS is true if an integer vector decreases.


  The integer array to search:

       1         2
       2         1
       3         4
       4         3
  The preceding vector is not descending.

  The integer array to search:

       1         4
       2         1
       3         3
       4         4
  The preceding vector is not descending.

  The integer array to search:

       1         2
       2         2
       3         3
       4         3
  The preceding vector is not descending.

  The integer array to search:

       1         2
       2         3
       3         3
       4         3
  The preceding vector is not descending.

  The integer array to search:

       1         3
       2         3
       3         3
       4         2
  The preceding vector is descending.

I4VEC_FRAC_test():
  I4VEC_FRAC: K-th smallest integer vector entry.


  The integer array to search:

       1        14
       2        10
       3         7
       4        11
       5        10
       6        18
       7         4
       8        18
       9        19
      10         1

       K       K-th smallest

         1         1
         2         4
         3         7
         4        10
         5        10
         6        11
         7        14
         8        18
         9        18
        10        19

I4VEC_INDEX_test():
  I4VEC_INDEX returns the index of the first occurrence
  of a given value in an integer vector.


  The integer array to search:

       1         5
       2         8
       3         1
       4         8
       5         6
       6         9
       7         2
       8         5
       9         8
      10         3
      11         6
      12         1
      13         7
      14         9
      15         1
      16         2
      17         8
      18         7
      19         6
      20         6

  The value searched for is        3
  The index of first occurrence is       10

I4VEC_MAXLOC_LAST_test():
  I4VEC_MAXLOC_LAST: index of the last maximal
  entry in an integer vector.


  The integer array to search:

       1         3
       2         5
       3         3
       4         2
       5         2
       6         4
       7         1
       8         5
       9         1
      10         4
      11         2
      12         1
      13         2
      14         5
      15         5
      16         3
      17         3
      18         1
      19         5
      20         4

  Index of last maximal entry is       19

I4VEC_PAIRWISE_PRIME_test():
  I4VEC_PAIRWISE_PRIME is true if an integer vector
  is pairwise prime.


  The integer array to check:

       1         3
       2         2
       3         1
       4         3
  The preceding vector is not pairwise prime.

  The integer array to check:

       1         1
       2         1
       3         1
       4         3
  The preceding vector is pairwise prime.

  The integer array to check:

       1         1
       2         2
       3         4
       4         1
  The preceding vector is not pairwise prime.

  The integer array to check:

       1         3
       2         4
       3         2
       4         4
  The preceding vector is not pairwise prime.

  The integer array to check:

       1         1
       2         2
       3         2
       4         4
  The preceding vector is not pairwise prime.

i4VEC_REVERSE_test():
  I4VEC_REVERSE reverses an integer vector.


  The integer array:

       1         1
       2         3
       3         5
       4         3
       5         5

  The reversed integer array:

       1         5
       2         3
       3         5
       4         3
       5         1

I4VEC_SORT_BUBBLE_A_test():
  I4VEC_SORT_BUBBLE_A ascending sorts an integer vector
  using bubble sort.


  Unsorted array:

       1        45
       2         3
       3        45
       4        43
       5        11
       6        32
       7         4
       8         1
       9         4
      10        52
      11        39
      12        41
      13        25
      14        24
      15        22
      16         3
      17        58
      18        39
      19        10
      20        26

  Sorted array:

       1         1
       2         3
       3         3
       4         4
       5         4
       6        10
       7        11
       8        22
       9        24
      10        25
      11        26
      12        32
      13        39
      14        39
      15        41
      16        43
      17        45
      18        45
      19        52
      20        58

I4VEC_SORT_HEAP_INDEX_D_test():
  I4VEC_SORT_HEAP_INDEX_D descending index-sorts
  an integer vector using heap sort.


  Unsorted array:

       1        52
       2        35
       3         6
       4        57
       5        22
       6        51
       7        58
       8        20
       9         9
      10        31
      11        29
      12        32
      13         2
      14        18
      15        38
      16        17
      17         4
      18         3
      19        34
      20        48

       I    INDX    A(INDX)

         1       7      58
         2       4      57
         3       1      52
         4       6      51
         5      20      48
         6      15      38
         7       2      35
         8      19      34
         9      12      32
        10      10      31
        11      11      29
        12       5      22
        13       8      20
        14      14      18
        15      16      17
        16       9       9
        17       3       6
        18      17       4
        19      18       3
        20      13       2
 
I4VEC_TRANSPOSE_PRINT_test():
  I4VEC_TRANSPOSE_PRINT prints an I4VEC
  with 5 entries to a row, and an optional title.
 
  Array printed by I4VEC_TRANSPOSE_PRINT:
           1           2           3           4           5
           6           7           8           9          10
          11          12
 
I4VEC_UNIFORM_AB_test():
  I4VEC_UNIFORM_AB computes pseudorandom values 
  in an interval [A,B].
 
  The lower endpoint A =         -100
  The upper endpoint B =          200

  The random vector:

       1        -2
       2        17
       3       -88
       4       174
       5       -88
       6       186
       7        18
       8       146
       9       118
      10       -89
      11       -50
      12       162
      13        97
      14        -7
      15       -29
      16        76
      17       123
      18       108
      19       123
      20       -71

INDEX_BOX_NEXT_2D_test():
  INDEX_BOX_NEXT_2D produces IJ indices that
  lie on the surface of a box in 2D.

  The box has logical dimensions:
     5  3

   #    I   J

    1  1  1
    2  1  2
    3  1  3
    4  2  1
    5  2  3
    6  3  1
    7  3  3
    8  4  1
    9  4  3
   10  5  1
   11  5  2
   12  5  3

INDEX_BOX_NEXT_3D_test():
  INDEX_BOX_NEXT_3D produces IJK indices that
  lie on the surface of a box.

  The box has logical dimensions:
     5  3  4

     #    I   J   K

    1  1  1  1
    2  1  1  2
    3  1  1  3
    4  1  1  4
    5  1  2  1
    6  1  2  2
    7  1  2  3
    8  1  2  4
    9  1  3  1
   10  1  3  2
   11  1  3  3
   12  1  3  4
   13  2  1  1
   14  2  1  2
   15  2  1  3
   16  2  1  4
   17  2  2  1
   18  2  2  4
   19  2  3  1
   20  2  3  2
   21  2  3  3
   22  2  3  4
   23  3  1  1
   24  3  1  2
   25  3  1  3
   26  3  1  4
   27  3  2  1
   28  3  2  4
   29  3  3  1
   30  3  3  2
   31  3  3  3
   32  3  3  4
   33  4  1  1
   34  4  1  2
   35  4  1  3
   36  4  1  4
   37  4  2  1
   38  4  2  4
   39  4  3  1
   40  4  3  2
   41  4  3  3
   42  4  3  4
   43  5  1  1
   44  5  1  2
   45  5  1  3
   46  5  1  4
   47  5  2  1
   48  5  2  2
   49  5  2  3
   50  5  2  4
   51  5  3  1
   52  5  3  2
   53  5  3  3
   54  5  3  4

INDEX_BOX2_NEXT_2D_test():
  INDEX_BOX2_NEXT_2D produces IJ indices that
  lie on the surface of a box2 in 2D.

  The box has half-widths:
     4  3

  and has center cell:
    10 20

     #    I   J

    1  6 17
    2  6 18
    3  6 19
    4  6 20
    5  6 21
    6  6 22
    7  6 23
    8  7 17
    9  7 23
   10  8 17
   11  8 23
   12  9 17
   13  9 23
   14 10 17
   15 10 23
   16 11 17
   17 11 23
   18 12 17
   19 12 23
   20 13 17
   21 13 23
   22 14 17
   23 14 18
   24 14 19
   25 14 20
   26 14 21
   27 14 22
   28 14 23

INDEX_BOX2_NEXT_3D_test():
  INDEX_BOX2_NEXT_3D produces IJK indices that
  lie on the surface of a box.

  The box has half widths:
     5  3  4

  and central cell:
    10 20 30

  We will only print a PORTION of the data!

   #    I   J   K

    1  5 17 26
    2  5 17 27
    3  5 17 28
    4  5 17 29
    5  5 17 30
    6  5 17 31
    7  5 17 32
    8  5 17 33
    9  5 17 34
   10  5 18 26
  370 15 23 26
  371 15 23 27
  372 15 23 28
  373 15 23 29
  374 15 23 30
  375 15 23 31
  376 15 23 32
  377 15 23 33
  378 15 23 34

INDEX_NEXT0_test():
  INDEX_NEXT0 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limit.

  Number of index entries =        3
  Coordinate maximum HI =          3

  Index arrays:

     1   1   1
     2   1   1
     3   1   1
     1   2   1
     2   2   1
     3   2   1
     1   3   1
     2   3   1
     3   3   1
     1   1   2
     2   1   2
     3   1   2
     1   2   2
     2   2   2
     3   2   2
     1   3   2
     2   3   2
     3   3   2
     1   1   3
     2   1   3
     3   1   3
     1   2   3
     2   2   3
     3   2   3
     1   3   3
     2   3   3
     3   3   3

INDEX_NEXT1_test():
  INDEX_NEXT1 generates all indices of an
  array of given shape, with
  lower limit 1 and given upper limits.

  Number of index entries =        3

  Coordinate maximum indices:

       1         4
       2         2
       3         3

  Index arrays:

     1   1   1
     2   1   1
     3   1   1
     4   1   1
     1   2   1
     2   2   1
     3   2   1
     4   2   1
     1   1   2
     2   1   2
     3   1   2
     4   1   2
     1   2   2
     2   2   2
     3   2   2
     4   2   2
     1   1   3
     2   1   3
     3   1   3
     4   1   3
     1   2   3
     2   2   3
     3   2   3
     4   2   3

INDEX_NEXT2_test():
  INDEX_NEXT2 generates all indices of an
  array of given shape with given
  lower and upper limits.

  Number of index entries =        3

  Coordinate, Maximum Index

         1        10        11
         2        -5        -3
         3         0         1

  Index arrays:

    10  -5   0
    11  -5   0
    10  -4   0
    11  -4   0
    10  -3   0
    11  -3   0
    10  -5   1
    11  -5   1
    10  -4   1
    11  -4   1
    10  -3   1
    11  -3   1

INDEX_RANK0_test():
  INDEX_RANK0 ranks an index with
  lower limit 1 and given upper limit.

  Number of index entries =        3

  Coordinate maximum Index =        3


  The index array:

       1         3
       2         1
       3         2

  The rank of this object is       12

INDEX_RANK1_test():
  INDEX_RANK1 ranks an index with
  lower limit 1 and given upper limits.

  Number of index entries =        3

  Coordinate, Maximum Index

           1         4
           2         2
           3         3

  The index array:

       1         4
       2         1
       3         2

  The rank of this object is       12

INDEX_RANK2_test():
  INDEX_RANK2 ranks an index with given
  lower and upper limits.

  Number of index entries =        3

  Coordinate, Minimum index, Maximum Index

           1         1        10
           4         2
           2         1        10
           4        11
           3         1        10
           4         6

  The index array:

       1         1
       2        11
       3         5

  The rank of this object is        7

INDEX_UNRANK0_test():
  INDEX_UNRANK0 unranks a multi-index.

  The multi-index has dimension        3

  The upper limit is HI =        3

  Rank, Multi-Index:

    1       1       1       1
    2       2       1       1
    3       3       1       1
    4       1       2       1
    5       2       2       1
    6       3       2       1
    7       1       3       1
    8       2       3       1
    9       3       3       1
   10       1       1       2
   11       2       1       2
   12       3       1       2
   13       1       2       2
   14       2       2       2
   15       3       2       2
   16       1       3       2
   17       2       3       2
   18       3       3       2
   19       1       1       3
   20       2       1       3
   21       3       1       3
   22       1       2       3
   23       2       2       3
   24       3       2       3
   25       1       3       3
   26       2       3       3
   27       3       3       3

INDEX_UNRANK1_test():
  INDEX_UNRANK1 unranks a multi-index.

  The multi-index has dimension        3

  The upper limits are:

           1         4
           2         2
           3         3

  Rank, Multi-Index:

    1       1       1       1
    2       2       1       1
    3       3       1       1
    4       4       1       1
    5       1       2       1
    6       2       2       1
    7       3       2       1
    8       4       2       1
    9       1       1       2
   10       2       1       2
   11       3       1       2
   12       4       1       2
   13       1       2       2
   14       2       2       2
   15       3       2       2
   16       4       2       2
   17       1       1       3
   18       2       1       3
   19       3       1       3
   20       4       1       3
   21       1       2       3
   22       2       2       3
   23       3       2       3
   24       4       2       3

INDEX_UNRANK2_test():
  INDEX_UNRANK2 unranks a multi-index.

  The multi-index has dimension        3

  The lower and upper limits are:

           1         1         2
           2        10        11
           3         4         6

  Rank, Multi-Index:

    7       1      11       5

INVERSE_MOD_N_test():
  INVERSE_MOD_N seeks Y, the inverse of B mod N,
  so that mod ( B * Y, N ) = 1, but returns 0
  if the inverse does not exist.

     B     N     Y     Z = mod ( B * Y, N )

     1     2     1     1
     1     3     1     1
     2     3     2     1
     1     4     1     1
     2     4     0     0
     3     4     3     1
     1     5     1     1
     2     5     3     1
     3     5     2     1
     4     5     4     1
     1     6     1     1
     2     6     0     0
     3     6     0     0
     4     6     0     0
     5     6     5     1
     1     7     1     1
     2     7     4     1
     3     7     5     1
     4     7     2     1
     5     7     3     1
     6     7     6     1
     1     8     1     1
     2     8     0     0
     3     8     3     1
     4     8     0     0
     5     8     5     1
     6     8     0     0
     7     8     7     1
     1     9     1     1
     2     9     5     1
     3     9     0     0
     4     9     7     1
     5     9     2     1
     6     9     0     0
     7     9     4     1
     8     9     8     1
     1    10     1     1
     2    10     0     0
     3    10     7     1
     4    10     0     0
     5    10     0     0
     6    10     0     0
     7    10     3     1
     8    10     0     0
     9    10     9     1

INVERSION_TO_PERM1_test():
  INVERSION_TO_PERM1: inversion => permutation (1,...,N).

    1  2  3  4  5
    3  5  1  4  2
    0  0  2  1  3
    3  5  1  4  2

INVOLUTE_ENUM_test():
  INVOLUTE_ENUM counts involutions;


         N    Number   Probability

         0         1     1.00000    
         1         1     1.00000    
         2         2     1.00000    
         3         4    0.666667    
         4        10    0.416667    
         5        26    0.216667    
         6        76    0.105556    
         7       232    0.460317E-01
         8       764    0.189484E-01
         9      2620    0.722002E-02
        10      9496    0.261684E-02

JFRAC_TO_RFRAC_test():
  JFRAC_TO_RFRAC converts a J fraction
  to a rational polynomial fraction.

  The original rational polynomial coefficients:

    0.992883      0.933171      0.690870      0.592380      0.748604    
    0.636182    
    0.732951      0.441874      0.886956      0.491752      0.153758E-01
     1.22787       1.00000    

  The J fraction coefficients:

    0.636182     -0.975969     -0.612873E-01   80.1721      -4.93349    
   -0.842303E-01
    0.511571E-01  0.519064      -7.09659       9.51865      -2.74182    
    0.977412    

  The recovered rational polynomial:

    0.992883      0.933171      0.690870      0.592380      0.748604    
    0.636182    
    0.732951      0.441874      0.886956      0.491752      0.153758E-01
     1.22787       1.00000    

JOSEPHUS_test():
  JOSEPHUS solves Josephus problems.

    N    M    K	 X

     41    3   41   31
     41  -38   41   31
     41    3   40   16
     64    2   64    1
   1000    2 1000  977

KSUB_NEXT_test():
  KSUB_NEXT generates all K subsets of an N set
  in lexicographic order.

     1       1   2   3
     2       1   2   4
     3       1   2   5
     4       1   3   4
     5       1   3   5
     6       1   4   5
     7       2   3   4
     8       2   3   5
     9       2   4   5
    10       3   4   5

KSUB_NEXT2_test():
  KSUB_NEXT2 generates the next K subset of an
  N set by the revolving door method.

  Rank  Subset  Added  Removed

     1   1 2 3    0        0
     2   1 3 4    4        2
     3   2 3 4    2        1
     4   1 2 4    1        3
     5   1 4 5    5        2
     6   2 4 5    2        1
     7   3 4 5    3        2
     8   1 3 5    1        4
     9   2 3 5    2        1
    10   1 2 5    1        3

KSUB_NEXT3_test():
  KSUB_NEXT3 generates all K subsets of an N set
  using the revolving door method.

  Rank    Subset  Added Removed

     1   1 2 3    0        0
     2   1 3 4    4        2
     3   2 3 4    2        1
     4   1 2 4    1        3
     5   1 4 5    5        2
     6   2 4 5    2        1
     7   3 4 5    3        2
     8   1 3 5    1        4
     9   2 3 5    2        1
    10   1 2 5    1        3

KSUB_NEXT4_test():
  KSUB_NEXT4 generates K subsets of an N set.
  N =        5
  K=         3

  Rank    Subset

     1       1   2   3
     2       1   2   4
     3       1   3   4
     4       2   3   4
     5       1   2   5
     6       1   3   5
     7       2   3   5
     8       1   4   5
     9       2   4   5
    10       3   4   5

KSUB_RANDOM_test():
  KSUB_RANDOM generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3

    2  3  5
    2  3  5
    1  2  5
    1  3  5
    1  2  5
    1  3  5
    1  2  5
    1  2  4
    2  3  4
    1  3  4

KSUB_RANDOM2_test():
  KSUB_RANDOM2 generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3

    1  2  3
    2  3  5
    2  3  5
    1  2  3
    2  3  5
    3  4  5
    1  2  5
    2  3  4
    1  3  4
    1  4  5

KSUB_RANDOM3_test():
  KSUB_RANDOM3 generates a random K-subset of an N-set.
  Set size is N =           5
  Subset size is K =        3

    1  4  5
    1  2  5
    1  3  4
    1  2  3
    1  3  4
    1  2  5
    1  2  3
    2  4  5
    1  2  5
    1  2  4

KSUB_RANDOM4_test():
  KSUB_RANDOM4 generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3

    1  3  4
    2  3  4
    1  3  4
    1  3  4
    2  3  4
    1  2  4
    1  3  4
    1  2  4
    2  3  4
    2  4  5

KSUB_RANDOM5_test():
  KSUB_RANDOM5 generates a random K subset of an N set.
  Set size is N =           5
  Subset size is K =        3

    1  3  4
    2  3  5
    2  3  4
    2  4  5
    2  4  5
    2  3  5
    1  2  4
    1  3  4
    1  3  5
    2  4  5

KSUB_RANK_test():
  KSUB_RANK: rank of a K subset of an N set.

  For N =        5
  and K =        3
  the subset is:
   1   3   5

  The rank is        6

ksub_to_comp_test():
  comp_to_ksub() returns the K subset corresponding to a composition.
  ksub_to_comp() returns the composition corresponding to a K subset.

  COMP:   1   0   0   2   7
  KSUB:   2   3   4   7
  COMP:   1   0   0   2   7

  COMP:   3   7   0   0   0
  KSUB:   4  12  13  14
  COMP:   3   7   0   0   0

  COMP:   0   0   6   0   4
  KSUB:   1   2   9  10
  COMP:   0   0   6   0   4

  COMP:   0   0   2   7   1
  KSUB:   1   2   5  13
  COMP:   0   0   2   7   1

  COMP:   0   0   3   1   6
  KSUB:   1   2   6   8
  COMP:   0   0   3   1   6

KSUB_TO_COMPNZ_test():
  KSUB_TO_COMPNZ returns the nonzero composition
  corresponding to a K subset.

  KSUB:     2   7   9  11
  COMPNZ:   2   5   2   2   4
  KSUB:     2   7   9  11

  KSUB:     1   2   5  11
  COMPNZ:   1   1   3   6   4
  KSUB:     1   2   5  11

  KSUB:     6   9  10  14
  COMPNZ:   6   3   1   4   1
  KSUB:     6   9  10  14

  KSUB:     5  10  11  12
  COMPNZ:   5   5   1   1   3
  KSUB:     5  10  11  12

  KSUB:     3   4  11  12
  COMPNZ:   3   1   7   1   3
  KSUB:     3   4  11  12

KSUB_UNRANK_test():
  KSUB_UNRANK: find the K-subset of an N set
  of a given rank.

  N is        5
  K is        3
  and the desired rank is        8

  The subset of the given rank is:
     1   4   5

L4VEC_NEXT_test():
  L4VEC_NEXT generates logical vectors.

  FFF
  FFT
  FTF
  FTT
  TFF
  TFT
  TTF
  TTT

MATRIX_PRODUCT_OPT_test():
  MATRIX_PRODUCT_OPT seeks the optimal order
  for a chain of matrix products.

  Matrix ranks:

         I         R         C

         1         4         2
         2         2         3
         3         3         1
         4         1         2
         5         2         2
         6         2         3

  Optimal cost is       36

  Ordering:

       1         2
       2         1
       3         4
       4         5
       5         3

MOEBIUS_MATRIX_test():
  MOEBIUS_MATRIX computes the Moebius matrix.

  The input matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        0      0      0      0      0      1      0      0      0      1
       2        0      0      1      1      0      0      0      0      0      0
       3        1      0      0      0      0      0      0      0      1      0
       4        1      0      0      0      1      0      0      0      1      0
       5        0      0      0      0      0      1      0      0      0      0
       6        0      0      0      0      0      0      1      0      0      0
       7        0      0      0      0      0      0      0      0      0      0
       8        0      1      0      0      0      0      0      0      0      0
       9        0      0      0      0      0      1      0      0      0      1
      10        0      0      0      0      0      0      1      0      0      0
      11        0      0      0      0      0      0      1      0      0      0

  Col        11
  Row

       1        0
       2        0
       3        0
       4        0
       5        0
       6        0
       7        0
       8        0
       9        1
      10        0
      11        0

  The Moebius matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        1      0      0      0      0     -1      1      0      0     -1
       2        1      1     -1     -1      0     -1      1      0      1     -1
       3       -1      0      1      0      0      1     -1      0     -1      1
       4       -1      0      0      1     -1      2     -1      0     -1      1
       5        0      0      0      0      1     -1      0      0      0      0
       6        0      0      0      0      0      1     -1      0      0      0
       7        0      0      0      0      0      0      1      0      0      0
       8        0     -1      0      0      0      0      0      1      0      0
       9        0      0      0      0      0     -1      2      0      1     -1
      10        0      0      0      0      0      0     -1      0      0      1
      11        0      0      0      0      0      0     -1      0      0      0

  Col        11
  Row

       1        0
       2        0
       3        0
       4        0
       5        0
       6        0
       7        0
       8        0
       9       -1
      10        0
      11        1

MONOMIAL_COUNT_test():
  MONOMIAL_COUNT counts the number of monomials of
  degrees 0 through DEGREE_MAX in a space of dimension DIM.

  DIM    Count

     1        10
     2        55
     3       220
     4       715
     5      2002
     6      5005

MONOMIAL_COUNTS_test():
  MONOMIAL_COUNTS counts the number of monomials of
  each degree 0 through DEGREE_MAX in a space of dimension DIM.

  DIM =        1

         0         1
         1         1
         2         1
         3         1
         4         1
         5         1
         6         1
         7         1
         8         1
         9         1

     Total        10

  DIM =        2

         0         1
         1         2
         2         3
         3         4
         4         5
         5         6
         6         7
         7         8
         8         9
         9        10

     Total        55

  DIM =        3

         0         1
         1         3
         2         6
         3        10
         4        15
         5        21
         6        28
         7        36
         8        45
         9        55

     Total       220

  DIM =        4

         0         1
         1         4
         2        10
         3        20
         4        35
         5        56
         6        84
         7       120
         8       165
         9       220

     Total       715

  DIM =        5

         0         1
         1         5
         2        15
         3        35
         4        70
         5       126
         6       210
         7       330
         8       495
         9       715

     Total      2002

  DIM =        6

         0         1
         1         6
         2        21
         3        56
         4       126
         5       252
         6       462
         7       792
         8      1287
         9      2002

     Total      5005

MORSE_THUE_test():
  MORSE_THUE computes the Morse-Thue numbers.

    0110100110
    0101101001
    0110011010
    0110010110
    0110100101
    1010011001
    0110100101
    1001101001
    0110100110
    0101100110
    1

MULTINOMIAL_COEF1_test():
  MULTINOMIAL_COEF1 computes multinomial
  coefficients using the Gamma function;

  Line 10 of the BINOMIAL table:

     0  10       1
     1   9      10
     2   8      45
     3   7     120
     4   6     210
     5   5     252
     6   4     210
     7   3     120
     8   2      45
     9   1      10
    10   0       1

  Level 5 of the TRINOMIAL coefficients:

     0   0   5       1
     0   1   4       5
     0   2   3      10
     0   3   2      10
     0   4   1       5
     0   5   0       1

     1   0   4       5
     1   1   3      20
     1   2   2      30
     1   3   1      20
     1   4   0       5

     2   0   3      10
     2   1   2      30
     2   2   1      30
     2   3   0      10

     3   0   2      10
     3   1   1      20
     3   2   0      10

     4   0   1       5
     4   1   0       5

     5   0   0       1

MULTINOMIAL_COEF2_test():
  MULTINOMIAL_COEF2 computes multinomial
  coefficients directly.

  Line 10 of the BINOMIAL table:

     0  10       1
     1   9      10
     2   8      45
     3   7     120
     4   6     210
     5   5     252
     6   4     210
     7   3     120
     8   2      45
     9   1      10
    10   0       1

  Level 5 of the TRINOMIAL coefficients:

     0   0   5       1
     0   1   4       5
     0   2   3      10
     0   3   2      10
     0   4   1       5
     0   5   0       1

     1   0   4       5
     1   1   3      20
     1   2   2      30
     1   3   1      20
     1   4   0       5

     2   0   3      10
     2   1   2      30
     2   2   1      30
     2   3   0      10

     3   0   2      10
     3   1   1      20
     3   2   0      10

     4   0   1       5
     4   1   0       5

     5   0   0       1

MULTIPERM_ENUM_test():
  MULTIPERM_ENUM enumerates multipermutations.

  N is the number of objects to be permuted.
  K is the number of distinct types of objects.
  COUNTS is the number of objects of each type.
  NUMBER is the number of multipermutations.

  Number       N       K       Counts(1:K)

       5       5       2     1     4
      10       5       2     3     2
     120       5       5     1     1     1     1     1
       1       5       1     5
     120       5       5     1     1     1     1     1

MULTIPERM_NEXT_test():
  MULTIPERM_NEXT computes multipermutations in
  lexical order.

     1     1   2   2   3   3   3
     2     1   2   3   2   3   3
     3     1   2   3   3   2   3
     4     1   2   3   3   3   2
     5     1   3   2   2   3   3
     6     1   3   2   3   2   3
     7     1   3   2   3   3   2
     8     1   3   3   2   2   3
     9     1   3   3   2   3   2
    10     1   3   3   3   2   2
    11     2   1   2   3   3   3
    12     2   1   3   2   3   3
    13     2   1   3   3   2   3
    14     2   1   3   3   3   2
    15     2   2   1   3   3   3
    16     2   2   3   1   3   3
    17     2   2   3   3   1   3
    18     2   2   3   3   3   1
    19     2   3   1   2   3   3
    20     2   3   1   3   2   3
    21     2   3   1   3   3   2
    22     2   3   2   1   3   3
    23     2   3   2   3   1   3
    24     2   3   2   3   3   1
    25     2   3   3   1   2   3
    26     2   3   3   1   3   2
    27     2   3   3   2   1   3
    28     2   3   3   2   3   1
    29     2   3   3   3   1   2
    30     2   3   3   3   2   1
    31     3   1   2   2   3   3
    32     3   1   2   3   2   3
    33     3   1   2   3   3   2
    34     3   1   3   2   2   3
    35     3   1   3   2   3   2
    36     3   1   3   3   2   2
    37     3   2   1   2   3   3
    38     3   2   1   3   2   3
    39     3   2   1   3   3   2
    40     3   2   2   1   3   3
    41     3   2   2   3   1   3
    42     3   2   2   3   3   1
    43     3   2   3   1   2   3
    44     3   2   3   1   3   2
    45     3   2   3   2   1   3
    46     3   2   3   2   3   1
    47     3   2   3   3   1   2
    48     3   2   3   3   2   1
    49     3   3   1   2   2   3
    50     3   3   1   2   3   2
    51     3   3   1   3   2   2
    52     3   3   2   1   2   3
    53     3   3   2   1   3   2
    54     3   3   2   2   1   3
    55     3   3   2   2   3   1
    56     3   3   2   3   1   2
    57     3   3   2   3   2   1
    58     3   3   3   1   2   2
    59     3   3   3   2   1   2
    60     3   3   3   2   2   1

NETWORK_FLOW_MAX_test():
  NETWORK_FLOW_MAX finds the maximum flow on a network.

  The source is node        1
  The sink is node          6

  Endpoint array:

    1  1  2  2  2  3  3  4  4  5  2  3  3  4  5  4  5  5  6  6
    2  3  3  4  5  4  5  5  6  6  1  1  2  2  2  3  3  4  4  5

  Input edge capacity array:

    3  7  2  5  4  1  4  2  8  3  0  0  0  0  0  0  0  0  0  0

  Reordered endpoint array:

    1  1  2  2  2  2  3  3  3  3  4  4  4  4  5  5  5  5  6  6
    2  3  1  3  4  5  1  2  4  5  2  3  5  6  2  3  4  6  4  5

  Output edge capacity/flow array:

    3  7  0  2  5  4  0  0  1  4  0  0  2  8  0  0  0  3  0  0
    3  4 -3  0  3  0 -4  0  1  3 -3 -1  0  4  0 -3  0  3 -4 -3

  Minimal node cut vector:

       1         1
       2         0
       3         1
       4         0
       5         1
       6         0

  Nodal flow vector:

       1         7
       2         3
       3         4
       4         4
       5         3
       6         7

NIM_SUM_test():
  NIM_SUM computes the Nim sum of two integers.

    I    J    Nim(I+J)


  I1, I2, I3 in decimal:

  282
  613
  895

  I1, I2, I3 in binary:

  00000000000000000000000100011010
  00000000000000000000001001100101
  00000000000000000000001101111111

  I1, I2, I3 in decimal:

  745
  637
  148

  I1, I2, I3 in binary:

  00000000000000000000001011101001
  00000000000000000000001001111101
  00000000000000000000000010010100

  I1, I2, I3 in decimal:

  951
  974
  121

  I1, I2, I3 in binary:

  00000000000000000000001110110111
  00000000000000000000001111001110
  00000000000000000000000001111001

  I1, I2, I3 in decimal:

  478
  935
  633

  I1, I2, I3 in binary:

  00000000000000000000000111011110
  00000000000000000000001110100111
  00000000000000000000001001111001

  I1, I2, I3 in decimal:

  260
  195
  455

  I1, I2, I3 in binary:

  00000000000000000000000100000100
  00000000000000000000000011000011
  00000000000000000000000111000111

PADOVAN_test():
  PADOVAN computes the Padovan numbers.


       N        P(N)

         0           1
         1           1
         2           1
         3           2
         4           2
         5           3
         6           4
         7           5
         8           7
         9           9
        10          12
        11          16
        12          21
        13          28
        14          37

PELL_BASIC_test():
  PELL_BASIC solves the basic Pell equation.

       D       X        Y         R

          2        3        2        1
          3        2        1        1
          5        9        4        1
          6        5        2        1
          7        8        3        1
          8        3        1        1
         10       19        6        1
         11       10        3        1
         12        7        2        1
         13      649      180        1
         14       15        4        1
         15        4        1        1
         17       33        8        1
         18       17        4        1
         19      170       39        1
         20        9        2        1

pell_next_test():
  pell_next() computes the "next" solution of the Pell equation.

       D       X        Y         R

          2        3        2        1
                  17       12        1
          3        2        1        1
                   7        4        1
          5        9        4        1
                 161       72        1
          6        5        2        1
                  49       20        1
          7        8        3        1
                 127       48        1
          8        3        1        1
                  17        6        1
         10       19        6        1
                 721      228        1
         11       10        3        1
                 199       60        1
         12        7        2        1
                  97       28        1
         13      649      180        1
              842401   233640        1
         14       15        4        1
                 449      120        1
         15        4        1        1
                  31        8        1
         17       33        8        1
                2177      528        1
         18       17        4        1
                 577      136        1
         19      170       39        1
               57799    13260        1
         20        9        2        1
                 161       36        1

pell_number_test():
  pell_number() evaluates the N-th Pell number.


  N    P(N)

           0         0
           1         1
           2         2
           3         5
           4        12
           5        29
           6        70
           7       169
           8       408
           9       985
          10      2378

PENT_ENUM_test():
  PENT_ENUM counts points in pentagons.


  N    Pent(N)

           0         0
           1         1
           2         5
           3        12
           4        22
           5        35
           6        51
           7        70
           8        92
           9       117
          10       145

PERM_ASCEND_test():
  PERM_ASCEND determines the length of the longest
  increasing subsequence in a permutation.

  The permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The length of the longest increasing subsequence is        5

  A longest increasing subsequence:

       1         2
       2         3
       3         6
       4         7
       5         8

PERM_FIXED_ENUM_test():
  PERM_FIXED_ENUM enumerates the permutations
  of N objects that leave M unchanged.

  For this test, N =       10

  M    F(N,M)

    0   1334961
    1   1334960
    2    667485
    3    222480
    4     55650
    5     11088
    6      1890
    7       240
    8        45
    9         0
   10         1

PERM0_CHECK_test():
  PERM0_CHECK checks a permutation of 0,...,N-1.


  Permutation 1:

     0   1   2   3   4
     5   2   3   4   1

PERM0_CHECK - Fatal error!
  Permutation is missing value    0

  Permutation 2:

     0   1   2   3   4
     4   1   3   0   2

  Permutation 3:

     0   1   2   3   4
     0   2   1   3   2

PERM0_CHECK - Fatal error!
  Permutation is missing value    4

PERM0_PRINT_test():
  PERM0_PRINT prints a permutation.

  The 0-based permutation:

     0   1   2   3   4   5   6
     6   1   3   0   4   2   5

PERM1_BREAK_COUNT_test():
  PERM1_BREAK_COUNT counts breaks in a permutation of (1,...,N).

  The permutation:

     1   2   3   4   5   6
     4   5   2   1   6   3

  The number of breaks is        5

PERM1_CANON_TO_CYCLE_test():
  PERM1_CANON_TO_CYCLE converts a permutation of (1,...,N) from
  canonical to cycle form.

  The permutation in canonical form:

     1   2   3   4   5   6
     4   5   2   1   6   3

  The permutation in cycle form:

     1   2   3   4   5   6
    -4   5  -2  -1   6   3

PERM1_CHECK_test():
  PERM1_CHECK checks a permutation of (1,...,N).


  Permutation 1:

     1   2   3   4   5
     5   2   3   4   1

  Permutation 2:

     1   2   3   4   5
     4   1   3   0   2

perm1_check(): Fatal error!
  Permutation is missing value    5

  Permutation 3:

     1   2   3   4   5
     0   2   1   3   2

perm1_check(): Fatal error!
  Permutation is missing value    4

PERM1_CYCLE_test():
  PERM1_CYCLE analyzes a permutation of (1,...,N).

  The permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  NCYCLE =        3
  ISGN =          1

  The permutation in cycle form:

     1   2   3   4   5   6   7   8   9
    -2   3   9  -6  -7   8   5   4   1

perm1_cycle_max_test():
  perm1_cycle_max() finds the length of a longest cycle
  in a permutation of 1 through N.

  The permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permutation in cycle form:

     1   2   3   4   5   6   7   8   9
    -1   2   3   9  -4   6   8  -5   7

  The longest cycle length is   4

perm1_cycle_stats_test():
  perm1_cycle_stats() counts cycles of each length
  in a permutation of 1 through N.

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  Cycle lengths:
     1     0
     2     1
     3     1
     4     1
     5     0
     6     0
     7     0
     8     0
     9     0

  Now average over 1000 permutations of length 100:

  Cycle length averages:
     1     1.00500         1.00000    
     2    0.478000        0.500000    
     3    0.336000        0.333333    
     4    0.251000        0.250000    
     5    0.184000        0.200000    
     6    0.193000        0.166667    
     7    0.130000        0.142857    
     8    0.140000        0.125000    
     9    0.107000        0.111111    
    10    0.940000E-01    0.100000    
    11    0.800000E-01    0.909091E-01
    12    0.990000E-01    0.833333E-01
    13    0.790000E-01    0.769231E-01
    14    0.680000E-01    0.714286E-01
    15    0.730000E-01    0.666667E-01
    16    0.660000E-01    0.625000E-01
    17    0.560000E-01    0.588235E-01
    18    0.490000E-01    0.555556E-01
    19    0.550000E-01    0.526316E-01
    20    0.440000E-01    0.500000E-01
    21    0.520000E-01    0.476190E-01
    22    0.420000E-01    0.454545E-01
    23    0.420000E-01    0.434783E-01
    24    0.410000E-01    0.416667E-01
    25    0.420000E-01    0.400000E-01
    26    0.430000E-01    0.384615E-01
    27    0.350000E-01    0.370370E-01
    28    0.370000E-01    0.357143E-01
    29    0.320000E-01    0.344828E-01
    30    0.400000E-01    0.333333E-01
    31    0.340000E-01    0.322581E-01
    32    0.270000E-01    0.312500E-01
    33    0.270000E-01    0.303030E-01
    34    0.160000E-01    0.294118E-01
    35    0.190000E-01    0.285714E-01
    36    0.210000E-01    0.277778E-01
    37    0.240000E-01    0.270270E-01
    38    0.220000E-01    0.263158E-01
    39    0.260000E-01    0.256410E-01
    40    0.240000E-01    0.250000E-01
    41    0.130000E-01    0.243902E-01
    42    0.270000E-01    0.238095E-01
    43    0.170000E-01    0.232558E-01
    44    0.190000E-01    0.227273E-01
    45    0.170000E-01    0.222222E-01
    46    0.240000E-01    0.217391E-01
    47    0.190000E-01    0.212766E-01
    48    0.220000E-01    0.208333E-01
    49    0.280000E-01    0.204082E-01
    50    0.220000E-01    0.200000E-01
    51    0.200000E-01    0.196078E-01
    52    0.240000E-01    0.192308E-01
    53    0.190000E-01    0.188679E-01
    54    0.130000E-01    0.185185E-01
    55    0.140000E-01    0.181818E-01
    56    0.150000E-01    0.178571E-01
    57    0.200000E-01    0.175439E-01
    58    0.170000E-01    0.172414E-01
    59    0.220000E-01    0.169492E-01
    60    0.190000E-01    0.166667E-01
    61    0.140000E-01    0.163934E-01
    62    0.150000E-01    0.161290E-01
    63    0.200000E-01    0.158730E-01
    64    0.190000E-01    0.156250E-01
    65    0.800000E-02    0.153846E-01
    66    0.160000E-01    0.151515E-01
    67    0.190000E-01    0.149254E-01
    68    0.190000E-01    0.147059E-01
    69    0.100000E-01    0.144928E-01
    70    0.200000E-01    0.142857E-01
    71    0.160000E-01    0.140845E-01
    72    0.150000E-01    0.138889E-01
    73    0.110000E-01    0.136986E-01
    74    0.100000E-01    0.135135E-01
    75    0.250000E-01    0.133333E-01
    76    0.140000E-01    0.131579E-01
    77    0.120000E-01    0.129870E-01
    78    0.110000E-01    0.128205E-01
    79    0.190000E-01    0.126582E-01
    80    0.130000E-01    0.125000E-01
    81    0.120000E-01    0.123457E-01
    82    0.120000E-01    0.121951E-01
    83    0.150000E-01    0.120482E-01
    84    0.120000E-01    0.119048E-01
    85    0.120000E-01    0.117647E-01
    86    0.800000E-02    0.116279E-01
    87    0.140000E-01    0.114943E-01
    88    0.600000E-02    0.113636E-01
    89    0.700000E-02    0.112360E-01
    90    0.110000E-01    0.111111E-01
    91    0.800000E-02    0.109890E-01
    92    0.180000E-01    0.108696E-01
    93    0.150000E-01    0.107527E-01
    94    0.700000E-02    0.106383E-01
    95    0.130000E-01    0.105263E-01
    96    0.800000E-02    0.104167E-01
    97    0.100000E-01    0.103093E-01
    98    0.900000E-02    0.102041E-01
    99    0.110000E-01    0.101010E-01
   100    0.150000E-01    0.100000E-01

PERM1_CYCLE_TO_CANON_test():
  PERM1_CYCLE_TO_CANON converts a permutation of (1,...,N) from
  cycle to canonical form.

  The permutation in cycle form:

     1   2   3   4   5   6
    -6   3   1  -5   4  -2

  The permutation in canonical form:

     1   2   3   4   5   6
     4   5   2   1   6   3

PERM1_CYCLE_TO_INDEX_test():
  PERM1_CYCLE_TO_INDEX converts a permutation of (1,...,N) from
  cycle to standard index form.

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permutation in cycle form:

     1   2   3   4   5   6   7   8   9
    -1   2   3   9  -4   6   8  -5   7

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

perm1_distance_test():
  perm1_distance computes the Ulam metric distance
  between two permutations of (1,...,N).

  Permutation P1

     1   2   3   4   5   6   7   8   9  10
     8  10   7   2   9   4   5   3   1   6

  Permutation P2

     1   2   3   4   5   6   7   8   9  10
     1   8   3   7   5   2   4   6   9  10

  Permutation P3

     1   2   3   4   5   6   7   8   9  10
    10   8   7   3   5   1   6   9   2   4

  K(P1,P1) should be 0.

  K(P1,P1) =        0

  K(P1,P2) should equal K(P2,P1).

  K(P1,P2) =        5
  K(P2,P1) =        5

  K(P1,P3) <= K(P1,P2) + K(P2,P3).

  K(P1,P3) =        5
  K(P1,P2) =        5
  K(P2,P3) =        5
  K(P1,P2) + K(P2,P3) =       10

PERM1_FREE_test():
  PERM1_FREE returns the unused values in a partial permutation of (1,...,N).
 
  Partial permutation:
  (empty vector)
 
  Values not yet used:
           1           2           3           4           5
 
  Partial permutation:
           5
 
  Values not yet used:
           1           2           3           4
 
  Partial permutation:
           5           2
 
  Values not yet used:
           1           3           4
 
  Partial permutation:
           5           2           3
 
  Values not yet used:
           1           4
 
  Partial permutation:
           5           2           3           4
 
  Values not yet used:
           1
 
  Partial permutation:
           5           2           3           4           1
 
  Values not yet used:
  (empty vector)

PERM1_INDEX_TO_CYCLE_test():
  PERM1_INDEX_TO_CYCLE converts a permutation of (1,...,N) from
  standard index to cycle form.

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permutation in cycle form:

     1   2   3   4   5   6   7   8   9
    -1   2   3   9  -4   6   8  -5   7

  The standard index form permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

PERM1_INVERSE_test():
  PERM1_INVERSE inverts a permutation of (1,...,N)


  The original permutation:

     1   2   3   4   5   6   7
     4   3   5   1   7   6   2

  The inverted permutation:

     1   2   3   4   5   6   7
     4   7   2   1   3   6   5

PERM1_INVERSE2_test():
  PERM1_INVERSE2 inverts a permutation of (1,...,N).

  The original permutation:

     1   2   3   4   5   6   7
     4   3   5   1   7   6   2

  The inverted permutation:

     1   2   3   4   5   6   7
     4   7   2   1   3   6   5

PERM1_INVERSE3_test():
  PERM1_INVERSE3 inverts a permutation of (1,...,N).

  The original permutation:

     1   2   3   4   5   6   7
     4   3   5   1   7   6   2

  The inverted permutation:

     1   2   3   4   5   6   7
     4   7   2   1   3   6   5

PERM1_LEX_NEXT_test():
  PERM1_LEX_NEXT generates permutations of (1,...,N).

     1   2   3   4
     1   2   4   3
     1   3   2   4
     1   3   4   2
     1   4   2   3
     1   4   3   2
     2   1   3   4
     2   1   4   3
     2   3   1   4
     2   3   4   1
     2   4   1   3
     2   4   3   1
     3   1   2   4
     3   1   4   2
     3   2   1   4
     3   2   4   1
     3   4   1   2
     3   4   2   1
     4   1   2   3
     4   1   3   2
     4   2   1   3
     4   2   3   1
     4   3   1   2
     4   3   2   1

PERM1_MUL_test():
  PERM1_MUL multiplies two permutations of (1,...,N).


  Permutation P1:

     1   2   3   4   5
     1   4   2   5   3

  Permutation P2:

     1   2   3   4   5
     3   2   4   1   5

  Product permutation:

     1   2   3   4   5
     3   1   2   5   4

PERM1_NEXT_test():
  PERM1_NEXT generates permutations of (1,...,N).

     1   2   3   4
     2   1   3   4
     3   1   2   4
     1   3   2   4
     2   3   1   4
     3   2   1   4
     4   2   1   3
     2   4   1   3
     1   4   2   3
     4   1   2   3
     2   1   4   3
     1   2   4   3
     1   3   4   2
     3   1   4   2
     4   1   3   2
     1   4   3   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     2   4   3   1
     4   2   3   1
     3   2   4   1
     2   3   4   1

PERM1_NEXT2_test():
  PERM1_NEXT2 generates permutations of (1,...,N).

     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4

PERM1_NEXT3_test():
  PERM1_NEXT3 generates permutations of (1,...,N).

     1   2   3   4
     1   2   4   3
     1   4   2   3
     4   1   2   3
     4   1   3   2
     1   4   3   2
     1   3   4   2
     1   3   2   4
     3   1   2   4
     3   1   4   2
     3   4   1   2
     4   3   1   2
     4   3   2   1
     3   4   2   1
     3   2   4   1
     3   2   1   4
     2   3   1   4
     2   3   4   1
     2   4   3   1
     4   2   3   1
     4   2   1   3
     2   4   1   3
     2   1   4   3
     2   1   3   4

PERM1_PRINT_test():
  PERM1_PRINT prints a permutation of (1,...,N).

  The 1-based permutation:

     1   2   3   4   5   6   7
     7   2   4   1   5   3   6

PERM1_RANDOM_test():
  PERM1_RANDOM produces a random permutation of (1,...,N);
  For this test, N =        4

     1   3   2   4
     3   2   4   1
     3   2   4   1
     3   4   1   2
     2   4   3   1

PERM1_RANDOM2_test():
  PERM1_RANDOM2 produces a random permutation of (1,...,N).
  For this test, N =        4

     1   3   2   4
     1   2   3   4
     2   4   1   3
     3   4   1   2
     4   1   2   3

PERM1_RANK_test():
  PERM1_RANK ranks a permutation of (1,...,N).

  The permutation:

     1   2   3   4
     1   4   2   3

  The rank is:       3

PERM1_SIGN_test():
  PERM1_SIGN computes the sign of a permutation of (1,...,N).

  RANK  SIGN  Permutation

     0     1     1   2   3   4
     1    -1     1   2   4   3
     2    -1     1   3   2   4
     3     1     1   3   4   2
     4     1     1   4   2   3
     5    -1     1   4   3   2
     6    -1     2   1   3   4
     7     1     2   1   4   3
     8     1     2   3   1   4
     9    -1     2   3   4   1
    10    -1     2   4   1   3
    11     1     2   4   3   1
    12     1     3   1   2   4
    13    -1     3   1   4   2
    14    -1     3   2   1   4
    15     1     3   2   4   1
    16     1     3   4   1   2
    17    -1     3   4   2   1
    18    -1     4   1   2   3
    19     1     4   1   3   2
    20     1     4   2   1   3
    21    -1     4   2   3   1
    22    -1     4   3   1   2
    23     1     4   3   2   1

PERM1_TO_EQUIV_test():
  PERM1_TO_EQUIV returns the set partition
  or equivalence classes determined by a
  permutation of (1,...,N).

  The input permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The partition:

   Set  Size
       1       4 ::    1   2   3   9
       2       3 ::    4   6   8
       3       2 ::    5   7

PERM1_TO_INVERSION_test():
  PERM1_TO_INVERSION: permutation (1,...,N) => inversion.

    1  2  3  4  5
    3  5  1  4  2
    0  0  2  1  3
    3  5  1  4  2

PERM1_TO_YTB_test():
  PERM1_TO_YTB converts a permutation of (1,...,N) to a
  Young table.

  The permutation:

     1   2   3   4   5   6   7
     7   2   4   1   5   3   6

  The Young table:

   1   3   5   6
   2   4
   7

PERM1_UNRANK_test():
  PERM1_UNRANK, given a rank, computes the
  corresponding permutation of (1,...,N).

  The requested rank is        6

  The permutation:

     1   2   3   4
     1   4   3   2

PERRIN_test():
  PERRIN computes the Perrin numbers.

     N        P(N)

         0         3
         1         0
         2         2
         3         3
         4         2
         5         5
         6         5
         7         7
         8        10
         9        12
        10        17
        11        22
        12        29
        13        39
        14        51

PORD_CHECK_test():
  PORD_CHECK checks a partial ordering.

  The partial ordering matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        1      0      0      0      0      0      0      0      0      0
       2        0      1      0      1      0      1      0      1      0      0
       3        1      0      1      1      0      0      0      0      0      0
       4        0      0      0      1      0      0      0      0      0      0
       5        1      1      1      1      1      1      1      1      0      1
       6        0      0      0      1      0      1      0      1      0      0
       7        1      0      1      1      0      1      1      1      0      1
       8        0      0      0      1      0      0      0      1      0      0
       9        0      0      0      0      0      0      0      0      0      0
      10        1      0      1      1      0      0      0      1      0      1

  CHECK FLAG =    0
  0 means no error.
  1 means illegal value of N.
  2 means some A(I,J) and A(J,I) are both nonzero.

POWER_MOD_test():
  POWER_MOD computes the remainder of a power
  of an integer modulo another integer.

  A =        7
  N =       50
  M =       11
  mod ( A**N, M ) =        1

  A =        3
  N =      118
  M =      119
  mod ( A**N, M ) =       32

POWER_SERIES1_test():
  POWER_SERIES1 composes a power series;

  Power series of G(x) = (1+F(x))**alpha

  N =       10
  ALPHA =    7.00000    

  Series for F(x):

     1.00000       0.00000       0.00000       0.00000       0.00000    
     0.00000       0.00000       0.00000       0.00000       0.00000    
  Series for G(x):

     7.00000       21.0000       35.0000       35.0000       21.0000    
     7.00000       1.00000       0.00000       0.00000       0.00000    

POWER_SERIES2_test():
  POWER_SERIES2 composes a power series;
  Here we compute the power series of G(x) = exp(F(x))-1
  The number of terms is N =        4

  Series for F(x):

    -4.00000       0.00000       0.00000       0.00000    

  Series for G(x):

    -4.00000       8.00000      -10.6667       10.6667    

POWER_SERIES3_test():
  POWER_SERIES3 composes a power series;

  Power series of H(x) = G(F(x))

  Number of terms, N =        4

  Series for F(x):

     1.00000       1.00000       0.00000       0.00000    

  Series for G(x):

     1.00000       1.00000       0.00000       0.00000    

  Series for H(x):

     1.00000       2.00000       2.00000       3.00000    

POWER_SERIES4_test():
  POWER_SERIES4 composes a power series;

  Power series of H(x) = G(1/F(x))

  N =       10

  Series for F(x):

     1.00000      0.500000      0.333333      0.250000      0.200000    
    0.166667      0.142857      0.125000      0.111111      0.100000    

  Series for G(x):

     1.00000       0.00000       0.00000       0.00000       0.00000    
     0.00000       0.00000       0.00000       0.00000       0.00000    

  Series for H(x):

     1.00000     -0.500000      0.166667     -0.416667E-01  0.833333E-02
   -0.138889E-02  0.198413E-03 -0.248016E-04  0.275573E-05 -0.275573E-06

PRIME_test():
  PRIME returns primes from a table.

  Number of primes stored is   1600

     I    Prime(I)

       1       2
       2       3
       3       5
       4       7
       5      11
       6      13
       7      17
       8      19
       9      23
      10      29

    1590   13411
    1591   13417
    1592   13421
    1593   13441
    1594   13451
    1595   13457
    1596   13463
    1597   13469
    1598   13477
    1599   13487
    1600   13499

PYTHAG_TRIPLE_NEXT_test():
  PYTHAG_TRIPLE_NEXT computes the "next"
  Pythagorean triple.

   I   J   A   B   C  A^2+B^2   C^2

     2   1   3   4   5      25      25
     3   2   5  12  13     169     169
     4   1  15   8  17     289     289
     4   3   7  24  25     625     625
     5   2  21  20  29     841     841
     5   4   9  40  41    1681    1681
     6   1  35  12  37    1369    1369
     6   3  27  36  45    2025    2025
     6   5  11  60  61    3721    3721
     7   2  45  28  53    2809    2809
     7   4  33  56  65    4225    4225
     7   6  13  84  85    7225    7225
     8   1  63  16  65    4225    4225
     8   3  55  48  73    5329    5329
     8   5  39  80  89    7921    7921
     8   7  15 112 113   12769   12769
     9   2  77  36  85    7225    7225
     9   4  65  72  97    9409    9409
     9   6  45 108 117   13689   13689
     9   8  17 144 145   21025   21025
    10   1  99  20 101   10201   10201

R8_AGM_test():
  R8_AGM computes the arithmetic-geometric mean (AGM)
  of two nonnegative real numbers.

    X        Y    R8_AGM(X,Y)

    3.0000    6.0000    4.3704
    2.0000    1.0000    1.4568
    4.0000    6.0000    4.9494
    4.0000    7.0000    5.3952
    9.0000    8.0000    8.4926
    2.0000    5.0000    3.3290
    1.0000    4.0000    2.2430
    7.0000    1.0000    3.2879
    2.0000    3.0000    2.4747
    1.0000    5.0000    2.6040

R8_CHOOSE_test():
  R8_CHOOSE evaluates C(N,K).

       N         K    CNK

         0         0   1.00000    
         1         0   1.00000    
         1         1   1.00000    
         2         0   1.00000    
         2         1   2.00000    
         2         2   1.00000    
         3         0   1.00000    
         3         1   3.00000    
         3         2   3.00000    
         3         3   1.00000    
         4         0   1.00000    
         4         1   4.00000    
         4         2   6.00000    
         4         3   4.00000    
         4         4   1.00000    

R8_FALL_test():
  R8_FALL computes the falling factorial function.

    X          N                Exact                  Computed

    5.0000     4     120.0000000000000         120.0000000000000    
    5.2500     4     163.1601562500000         163.1601562500000    
    5.5000     4     216.5625000000000         216.5625000000000    
    5.7500     4     281.6601562500000         281.6601562500000    
    6.0000     4     360.0000000000000         360.0000000000000    
    7.5000     0     1.000000000000000         1.000000000000000    
    7.5000     1     7.500000000000000         7.500000000000000    
    7.5000     2     48.75000000000000         48.75000000000000    
    7.5000     3     268.1250000000000         268.1250000000000    
    7.5000     4     1206.562500000000         1206.562500000000    
    7.5000     5     4222.968750000000         4222.968750000000    
    7.5000     6     10557.42187500000         10557.42187500000    
    7.5000     7     15836.13281250000         15836.13281250000    
    7.5000     8     7918.066406250000         7918.066406250000    
    7.5000     9    -3959.033203125000        -3959.033203125000    

R8_RISE_test():
  R8_RISE computes the rising factorial function.

    X          N                Exact                  Computed

    5.0000     4     1680.000000000000         1680.000000000000    
    5.2500     4     1962.597656250000         1962.597656250000    
    5.5000     4     2279.062500000000         2279.062500000000    
    5.7500     4     2631.972656250000         2631.972656250000    
    6.0000     4     3024.000000000000         3024.000000000000    
    7.5000     0     1.000000000000000         1.000000000000000    
    7.5000     1     7.500000000000000         7.500000000000000    
    7.5000     2     63.75000000000000         63.75000000000000    
    7.5000     3     605.6250000000000         605.6250000000000    
    7.5000     4     6359.062500000000         6359.062500000000    
    7.5000     5     73129.21875000000         73129.21875000000    
    7.5000     6     914115.2343750000         914115.2343750000    
    7.5000     7     12340555.66406250         12340555.66406250    
    7.5000     8     178938057.1289063         178938057.1289062    
    7.5000     9     2773539885.498047         2773539885.498047    

R8_TO_CFRAC_test():
  R8_TO_CFRAC converts a real number to a
  a sequence of continued fraction convergents.

  Use the real number R =    6.28319    

             6           6           1   6.00000      0.283185    
             3          19           3   6.33333     -0.501480E-01
             1          25           4   6.25000      0.331853E-01
             1          44           7   6.28571     -0.252898E-02
             7         333          53   6.28302      0.166439E-03
             2         710         113   6.28319     -0.533528E-06
           146      103993       16551   6.28319      0.115578E-08
             3      312689       49766   6.28319     -0.582867E-10
             6     1980127      315147   6.28319      0.547384E-11
             1     2292816      364913   6.28319     -0.322142E-11
             1     4272943      680060   6.28319      0.808242E-12

R8_TO_DEC_test():
  R8_TO_DEC converts a real number to a decimal;

  The number of decimal digits is   5

     R   =>  A * 10^B  =>  R2

    4.348985      4349        -3    4.349000
    1.860759     18608        -4    1.860800
    2.531477     25315        -4    2.531500
   -6.095902    -60959        -4   -6.095900
    2.873193     28732        -4    2.873200
   -7.372701    -73727        -4   -7.372700
    2.969622     29696        -4    2.969600
    9.738287     97383        -4    9.738300
   -4.460653    -44607        -4   -4.460700
    3.658318     36583        -4    3.658300

R8_TO_RAT_test():
  R8_TO_RAT converts a real number to a rational;

  The maximum number of digits allowed is   4

     R   =>  A / B  =>  R2

    2.995186    1872       625  2.995200
    2.054752    5137      2500  2.054800
    0.960111    9601     10000  0.960100
    5.128706   51287     10000  5.128700
   -0.565386   -2827      5000 -0.565400
    4.131112   41311     10000  4.131100
   -0.072769     -91      1250 -0.072800
    5.728782    7161      1250  5.728800
    2.064720   20647     10000  2.064700
   -1.553455   -3107      2000 -1.553500

R8MAT_DET_test():
  R8MAT_DET: determinant of a real matrix.


  The 123/456/789 matrix:

  Col         1             2             3       
  Row

    1       1.            2.            3.      
    2       4.            5.            6.      
    3       7.            8.            9.      

  Determinant of the 123/456/789 matrix is    0.00000    

  The Hilbert matrix:

  Col         1             2             3             4       
  Row

    1   0.500000      0.333333      0.250000      0.200000    
    2   0.333333      0.250000      0.200000      0.166667    
    3   0.250000      0.200000      0.166667      0.142857    
    4   0.200000      0.166667      0.142857      0.125000    

  Determinant of the Hilbert matrix is   0.236206E-08

  The -1,2,-1 matrix:

  Col         1             2             3       
  Row

    1       2.           -1.            0.      
    2      -1.            2.           -1.      
    3       0.           -1.            2.      

  Determinant of the -1,2,-1 matrix is    4.00000    

R8MAT_PERM1_test():
  R8MAT_PERM1 reorders a real matrix in place.
  The rows and columns use the same permutation.

  The original matrix

  Col         1             2             3             4             5       
  Row

    1      11.           12.           13.           14.           15.      
    2      21.           22.           23.           24.           25.      
    3      31.           32.           33.           34.           35.      
    4      41.           42.           43.           44.           45.      
    5      51.           52.           53.           54.           55.      
    6      61.           62.           63.           64.           65.      
    7      71.           72.           73.           74.           75.      
    8      81.           82.           83.           84.           85.      
    9      91.           92.           93.           94.           95.      

  Col         6             7             8             9       
  Row

    1      16.           17.           18.           19.      
    2      26.           27.           28.           29.      
    3      36.           37.           38.           39.      
    4      46.           47.           48.           49.      
    5      56.           57.           58.           59.      
    6      66.           67.           68.           69.      
    7      76.           77.           78.           79.      
    8      86.           87.           88.           89.      
    9      96.           97.           98.           99.      

  The row and column permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The permuted matrix

  Col         1             2             3             4             5       
  Row

    1      99.           91.           92.           98.           97.      
    2      19.           11.           12.           18.           17.      
    3      29.           21.           22.           28.           27.      
    4      89.           81.           82.           88.           87.      
    5      79.           71.           72.           78.           77.      
    6      49.           41.           42.           48.           47.      
    7      59.           51.           52.           58.           57.      
    8      69.           61.           62.           68.           67.      
    9      39.           31.           32.           38.           37.      

  Col         6             7             8             9       
  Row

    1      94.           95.           96.           93.      
    2      14.           15.           16.           13.      
    3      24.           25.           26.           23.      
    4      84.           85.           86.           83.      
    5      74.           75.           76.           73.      
    6      44.           45.           46.           43.      
    7      54.           55.           56.           53.      
    8      64.           65.           66.           63.      
    9      34.           35.           36.           33.      

R8MAT_2PERM1_test():
  R8MAT_2PERM1 reorders a real matrix in place.
  Rows and columns use different permutations.

  The original matrix

  Col         1             2             3             4             5       
  Row

    1      11.           12.           13.           14.           15.      
    2      21.           22.           23.           24.           25.      
    3      31.           32.           33.           34.           35.      
    4      41.           42.           43.           44.           45.      
    5      51.           52.           53.           54.           55.      
    6      61.           62.           63.           64.           65.      
    7      71.           72.           73.           74.           75.      
    8      81.           82.           83.           84.           85.      
    9      91.           92.           93.           94.           95.      

  Col         6             7       
  Row

    1      16.           17.      
    2      26.           27.      
    3      36.           37.      
    4      46.           47.      
    5      56.           57.      
    6      66.           67.      
    7      76.           77.      
    8      86.           87.      
    9      96.           97.      

  The row permutation:

     1   2   3   4   5   6   7   8   9
     2   3   9   6   7   8   5   4   1

  The column permutation:

     1   2   3   4   5   6   7
     3   4   5   6   7   1   2

  The permuted matrix

  Col         1             2             3             4             5       
  Row

    1      96.           97.           91.           92.           93.      
    2      16.           17.           11.           12.           13.      
    3      26.           27.           21.           22.           23.      
    4      86.           87.           81.           82.           83.      
    5      76.           77.           71.           72.           73.      
    6      46.           47.           41.           42.           43.      
    7      56.           57.           51.           52.           53.      
    8      66.           67.           61.           62.           63.      
    9      36.           37.           31.           32.           33.      

  Col         6             7       
  Row

    1      94.           95.      
    2      14.           15.      
    3      24.           25.      
    4      84.           85.      
    5      74.           75.      
    6      44.           45.      
    7      54.           55.      
    8      64.           65.      
    9      34.           35.      

R8MAT_PERMANENT_test():
  R8MAT_PERMANENT: the matrix permanent function.
  We will analyze matrices with 0 diagonal and
  1 on all offdiagonals.

  Order	    Permanent.

        2           1.000000000    
        3           2.000000000    
        4           9.000000000    
        5           44.00000000    
        6           265.0000000    
        7           1854.000000    
        8           14833.00000    
        9           133496.0000    
       10           1334961.000    
       11           14684570.00    
       12           176214841.0    

R8POLY_test():
  R8POLY converts between power sum, factorial
  and Taylor forms, and can evaluate a polynomial

  All calls have input A as follows
     0.00   0.00   0.00   0.00   0.00   1.00

  Option IOPT =       -3
  Output array = 
     0.00  24.00 -50.00  35.00 -10.00   1.00

  Option IOPT =       -2
  Output array = 
     0.00   1.00  15.00  25.00  10.00   1.00

  Option IOPT =       -1
  X0 =    2.00000    
  Value =    0.00000    

  Option IOPT =        0
  X0 =    2.00000    
  Value =    32.0000    

  Option IOPT =        6
  X0 =    2.00000    
  Output array = 
    32.00  80.00  80.00  40.00  10.00   1.00

  Option IOPT =        6
  X0 =   -2.00000    
  Output array = 
   -32.00  80.00 -80.00  40.00 -10.00   1.00

R8POLY_F2P_test():
  R8POLY_F2P: factorial => power sum.

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  The factorial polynomial coefficients:

       1   1.00000    
       2   9.00000    
       3   15.0000    
       4   4.00000    

  The recovered power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

R8POLY_FVAL_test():
  R8POLY_FVAL evaluates a polynomial in factorial form.

  The factorial polynomial coefficients:

       1   1.00000    
       2   2.00000    
       3   3.00000    
       4   4.00000    
       5   5.00000    

  R8POLY (   2.00000     ) =    11.0000    
  The correct value is 11.

R8POLY_N2P_test():
  R8POLY_N2P: Newton => power sum;

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  Newton polynomial coefficients:

     49.0000    132.0000     51.0000      4.0000

  Newton polynomial abscissas:

      2.0000      4.0000      6.0000      8.0000

  The recovered power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

R8POLY_NVAL_test():
  R8POLY_NVAL evaluates a Newton polynomial.

  Newton polynomial coefficients:

        1.0000      2.0000      3.0000      4.0000      5.0000

  Newton polynomial abscissas:

        0.0000      1.0000      2.0000      3.0000

  R8POLY (    2.00000     ) =    11.0000    
  The correct value is 11.

R8POLY_NX_test():
  R8POLY_NX replaces one abscissa in a Newton polynomial.

  Newton polynomial coefficients:

       1   1.00000    
       2   2.00000    
       3   3.00000    

  Newton polynomial abscissas:

       1   1.00000    
       2   2.00000    
       3   3.00000    

  Replace one abscissa by X =    0.00000    

  Revised Newton polynomial coefficients:

       1   5.00000    
       2  -4.00000    
       3   3.00000    

  Revised Newton polynomial abscissas:

       1   0.00000    
       2   1.00000    
       3   2.00000    

R8POLY_P2F_test():
  R8POLY_P2F: power sum => factorial;

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  The factorial polynomial coefficients:

       1   1.00000    
       2   9.00000    
       3   15.0000    
       4   4.00000    

  The recovered power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

R8POLY_P2N_test():
  R8POLY_P2N: Power sum => Newton.

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  Newton polynomial coefficients:

     49.0000    132.0000     51.0000      4.0000

  Newton polynomial abscissas:

      2.0000      4.0000      6.0000      8.0000

  The recovered power sum polynomial:

  p(x) =     4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

R8POLY_P2T_test():
  R8POLY_P2T: Power sum => Taylor.

  Taylor expansion point is X =    2.00000    

  The Taylor coefficients:

        1.0000      2.0000      3.0000      4.0000

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         -   21.0000     * x ^   2
         +   38.0000     * x
         -   23.0000    

  The recovered Taylor coefficients:

        1.0000      2.0000      3.0000      4.0000

R8POLY_PRINT_test():
  R8POLY_PRINT prints an R8POLY.

  The polynomial:

  p(x) =     1.40000     * x ^   4
         +   3.30000     * x ^   3
         +   2.20000     * x ^   2
         +   5.10000     * x
         -   2.00000    

R8POLY_PVAL_test():
  R8POLY_PVAL evaluates a polynomial
  in power sum form.

  The polynomial to be evaluated:

  p(x) =     5.00000     * x ^   4
         +   4.00000     * x ^   3
         +   3.00000     * x ^   2
         +   2.00000     * x
         +   1.00000    

  At X =    2.00000    
  Computed polynomial value is    129.000    
  Correct value is 129.

R8POLY_T2P_test():
  R8POLY_T2P: Taylor => Power sum;

  Taylor expansion point is X =    2.00000    

  The Taylor coefficients:

        1.0000      2.0000      3.0000      4.0000

  The power sum polynomial:

  p(x) =     4.00000     * x ^   3
         -   21.0000     * x ^   2
         +   38.0000     * x
         -   23.0000    

  The recovered Taylor coefficients:

        1.0000      2.0000      3.0000      4.0000

R8VEC_BACKTRACK_test():
  R8VEC_BACKTRACK uses backtracking, seeking a vector X
  of N values which satisfies some condition.

  In this demonstration, we have 8 integers W(I).
  We seek all subsets that sum to 53.
  X(I) is 0 or 1 if the entry is skipped or used.

   1      53.00:     15.00   22.00   16.00
   2      53.00:     15.00   14.00   16.00    8.00
   3      53.00:     22.00   14.00    9.00    8.00

  Done!

r8vec_frac_test():
  r8vec_frac(): K-th smallest real vector entry;

  The real array to search:

       1   4.34918    
       2   3.23799    
       3   9.77906    
       4   5.27034    
       5  0.492133    
       6   3.35761    
       7   5.83207    
       8   7.83098    
       9   7.88776    
      10   7.00444    

  Frac   R8VEC_FRAC

     1    0.492133    
     2     3.23799    
     3     3.35761    
     4     4.34918    
     5     5.27034    
     6     5.83207    
     7     7.00444    
     8     7.83098    
     9     7.88776    
    10     9.77906    

R8VEC_MIRROR_NEXT_test():
  R8VEC_MIRROR_NEXT generates all sign variations
  of a real vector.

  Next vector:

       1   1.00000    
       2   2.00000    
       3   3.00000    

  Next vector:

       1  -1.00000    
       2   2.00000    
       3   3.00000    

  Next vector:

       1   1.00000    
       2  -2.00000    
       3   3.00000    

  Next vector:

       1  -1.00000    
       2  -2.00000    
       3   3.00000    

  Next vector:

       1   1.00000    
       2   2.00000    
       3  -3.00000    

  Next vector:

       1  -1.00000    
       2   2.00000    
       3  -3.00000    

  Next vector:

       1   1.00000    
       2  -2.00000    
       3  -3.00000    

  Next vector:

       1  -1.00000    
       2  -2.00000    
       3  -3.00000    

  Done.

  Next vector:

       1   1.00000    
       2   0.00000    
       3   3.00000    

  Next vector:

       1  -1.00000    
       2   0.00000    
       3   3.00000    

  Next vector:

       1   1.00000    
       2  -0.00000    
       3  -3.00000    

  Next vector:

       1  -1.00000    
       2  -0.00000    
       3  -3.00000    

  Done.

RAT_ADD_test():
  RAT_ADD adds two rationals.

  A = 3/4
  B = 10/7
  C = A + B = 61/28

RAT_DIV_test():
  RAT_DIV divides two rationals.

  A = 3/4
  B = 10/7
  C = A / B = 21/40

RAT_FAREY_test():
  RAT_FAREY computes a row of the Farey fraction table.

  Row        1
  Number of fractions:        2

    0  1
    1  1

  Row        2
  Number of fractions:        3

    0  1  1
    1  2  1

  Row        3
  Number of fractions:        5

    0  1  1  2  1
    1  3  2  3  1

  Row        4
  Number of fractions:        7

    0  1  1  1  2  3  1
    1  4  3  2  3  4  1

  Row        5
  Number of fractions:       11

    0  1  1  1  2  1  3  2  3  4  1
    1  5  4  3  5  2  5  3  4  5  1

  Row        6
  Number of fractions:       13

    0  1  1  1  1  2  1  3  2  3  4  5  1
    1  6  5  4  3  5  2  5  3  4  5  6  1

  Row        7
  Number of fractions:       19

    0  1  1  1  1  2  1  2  3  1  4  3  2  5  3  4  5  6  1
    1  7  6  5  4  7  3  5  7  2  7  5  3  7  4  5  6  7  1

RAT_FAREY2_test():
  RAT_FAREY2 computes a row of the Farey fraction table.

  Row        1

    0  1
    1  1

  Row        2

    0  1  1
    1  2  1

  Row        3

    0  1  1  2  1
    1  3  2  3  1

  Row        4

    0  1  1  2  1  3  2  3  1
    1  4  3  5  2  5  3  4  1

  Row        5

    0  1  1  2  1  3  2  3  1  4  3  5  2  5  3  4  1
    1  5  4  7  3  8  5  7  2  7  5  8  3  7  4  5  1

RAT_MUL_test():
  RAT_MUL multiplies two rationals.

  A = 3/4
  B = 10/7
  C = A * B = 15/14

RAT_NORMALIZE_test():
  RAT_NORMALIZE normalizes a rational.

           A           B             A             B
                                 normalized     normalized

           3           4             3           4
           1        1000             1        1000
          20           1            20           1
           8           4             2           1
         -10           7           -10           7
           9         -15            -3           5
         -11         -11             1           1

RAT_SUM_FORMULA_test():
  RAT_SUM_FORMULA computes the coefficients for the
  formulas for the sums of powers of integers.

  Power Sum Coefficients:

    1    0    0    0    0    0    0


    1    1    0    0    0    0    0
    2    2

    1    1    1    0    0    0    0
    3    2    6

    1    1    1    0    0    0    0
    4    2    4

    1    1    1    0   -1    0    0
    5    2    3        30

    1    1    5    0   -1    0    0
    6    2   12        12

    1    1    1    0   -1    0    1
    7    2    2         6        42

RAT_TO_CFRAC_test():
  RAT_TO_CFRAC fraction => continued fraction,

  Regular fraction is     4096 /    15625

  Continued fraction coefficients:

       1         0
       2         3
       3         1
       4         4
       5         2
       6         1
       7         1
       8        11
       9        13

  The continued fraction convergents.
  The last row contains the value of the continued
  fraction, written as a common fraction.

  I, P(I), Q(I), P(I)/Q(I)

    1       0       1   0.00000    
    2       1       3  0.333333    
    3       1       4  0.250000    
    4       5      19  0.263158    
    5      11      42  0.261905    
    6      16      61  0.262295    
    7      27     103  0.262136    
    8     313    1194  0.262144    
    9    4096   15625  0.262144    

RAT_TO_DEC_test():
  RAT_TO_DEC fraction => decimal,

  In this test, choose the top and bottom
  of a rational at random, and compute the
  equivalent real number.

  Then convert to decimal, and the equivalent real.

  Then convert back to rational and the equivalent real.

    1.668639=         564/         338
    1.668639=  1668639053*10^          -9
    1.668639=  1668639053/  1000000000

    2.286765=         311/         136
    2.286765=   228676470*10^          -8
    2.286765=    22867647/    10000000

    0.292290=         254/         869
    0.292290=   292289988*10^          -9
    0.292290=    73072497/   250000000

    4.461538=          58/          13
    4.461538=   446153846*10^          -8
    4.461538=   223076923/    50000000

   -1.721649=        -167/          97
   -1.721649= -1721649484*10^          -9
   -1.721649=  -430412371/   250000000

    3.572519=         936/         262
    3.572519=   357251908*10^          -8
    3.572519=    89312977/    25000000

   -4.118227=        -836/         203
   -4.118227=  -411822660*10^          -8
   -4.118227=   -20591133/     5000000

   -3.023438=        -774/         256
   -3.023438=   -30234375*10^          -7
   -3.023438=        -387/         128

   -0.728649=        -674/         925
   -0.728649=  -728648648*10^          -9
   -0.728649=   -91081081/   125000000

    0.652542=         616/         944
    0.652542=   652542372*10^          -9
    0.652542=   163135593/   250000000

RAT_TO_R8_test():
  RAT_TO_R8 converts a rational to a real number.

  The maximum number of digits allowed is   4

     R   =>  A / B  =>  R2

    0.614469    1229      2000  0.614500
   -1.009046   -1009      1000 -1.009000
   -1.824379   -4561      2500 -1.824400
    5.952662   59527     10000  5.952700
   -0.478453    -957      2000 -0.478500
   -1.321889  -13219     10000 -1.321900
    4.427049    4427      1000  4.427000
    1.236066   12361     10000  1.236100
    3.760840    4701      1250  3.760800
   -2.023726  -20237     10000 -2.023700

RAT_TO_S_test():
  RAT_TO_S converts a rational to a string.

           A           B    A/B

           3           4      3/4
           1        1000      1/1000
          20           1      20
           8           4      8/4
         -10           7      -10/7
           9         -15      9/-15
         -11         -11      -11/-11

RAT_WIDTH_test():
  RAT_WIDTH determines the "width" of a rational.

     Top    Bottom  Width

      1000       3       4
      1000      40       4
      1000     500       4
      1000    6000       4
      1000   70000       5
         1       1       1
        -1     200       3
       -10     200       3
      -100     200       4
     -1000     200       5
         1    -200       3
        10    -200       3
       100    -200       4
      1000    -200       5
     10000    -200       6
        17    3000       4
   4000000 4000000       7

RATMAT_DET_test():
  RATMAT_DET: determinant of a rational matrix.


  The 123/456/789 matrix:

   1   2   3


   4   5   6


   7   8   9


  Determinant of the 123/456/789 matrix:
         0 /        1

  The Hilbert matrix:

   1   1   1
   2   3   4

   1   1   1
   3   4   5

   1   1   1
   4   5   6

  Determinant of the Hilbert matrix:
         1 /    43200

  The -1 2 -1 matrix:

   2  -1   0


  -1   2  -1


   0  -1   2


  Determinant of the -1,2,-1 matrix:
         4 /        1

RATMAT_PRINT_test():
  RATMAT_PRINT prints a rational matrix.

  The Hilbert matrix:

   1   1   1
   2   3   4

   1   1   1
   3   4   5

   1   1   1
   4   5   6

   1   1   1
   5   6   7

REGRO_NEXT_test():
  REGRO_NEXT generates all restricted growth 
  functions.

    1  1  1  1  1
    2  1  1  1  2
    3  1  1  2  1
    4  1  1  2  2
    5  1  1  2  3
    6  1  2  1  1
    7  1  2  1  2
    8  1  2  1  3
    9  1  2  2  1
   10  1  2  2  2
   11  1  2  2  3
   12  1  2  3  1
   13  1  2  3  2
   14  1  2  3  3
   15  1  2  3  4

RFRAC_TO_CFRAC_test():
  RFRAC_TO_CFRAC: ratio to continued fration.

  Rational polynomial fraction coefficients:

  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000

  Continued fraction coefficients:

       1   1.00000    
       2  0.500000    
       3   1.33333    
       4 -0.500000    
       5  -1.50000    
       6   2.00000    

  Recovered rational polynomial:

  P:        1.0000      1.0000      2.0000
  Q:        1.0000      3.0000      1.0000      1.0000

RFRAC_TO_JFRAC_test():
  RFRAC_TO_JFRAC converts a rational polynomial
  fraction to a J fraction.

  The original rational polynomial coefficients:

    0.360144E-01  0.914884      0.108003      0.810162      0.601316    
    0.150506E-02
    0.641958      0.930626       2.89074       1.44061      0.925021    
     1.34578       1.00000    

  The J fraction coefficients:

    0.150506E-02   158549.      0.275351E-02   9.40356      0.335013    
    0.228316    
    -398.184       398.178       3.81934      -2.60744     -0.610664E-02
    0.145642    

  The recovered rational polynomial:

    0.360144E-01  0.914884      0.108003      0.810162      0.601316    
    0.150506E-02
    0.641958      0.930626       2.89074       1.44061      0.925021    
     1.34578       1.00000    

SCHROEDER_test():
  SCHROEDER computes the Schroeder numbers.

       N        S(N)

         1         1
         2         1
         3         3
         4        11
         5        45
         6       197
         7       903
         8      4279
         9     20793
        10    103049

SORT_HEAP_EXTERNAL_test():
  SORT_HEAP_EXTERNAL sorts objects externally.

  Unsorted array:

       1         1
       2         9
       3        13
       4         8
       5        12
       6        16
       7         7
       8         1
       9        19
      10         8
      11        16
      12        18
      13        10
      14         1
      15        11
      16         3
      17        16
      18         7
      19        15
      20        20

  Sorted array:

       1         1
       2         1
       3         1
       4         3
       5         7
       6         7
       7         8
       8         8
       9         9
      10        10
      11        11
      12        12
      13        13
      14        15
      15        16
      16        16
      17        16
      18        18
      19        19
      20        20

SUBCOMP_NEXT_test():
  SUBCOMP_NEXT generates subcompositions.

  Seek all subcompositions of N =        6
  using K =        3 parts.

     #   Sum

     1     0     0   0   0
     2     1     1   0   0
     3     1     0   1   0
     4     1     0   0   1
     5     2     2   0   0
     6     2     1   1   0
     7     2     0   2   0
     8     2     1   0   1
     9     2     0   1   1
    10     2     0   0   2
    11     3     3   0   0
    12     3     2   1   0
    13     3     1   2   0
    14     3     0   3   0
    15     3     2   0   1
    16     3     1   1   1
    17     3     0   2   1
    18     3     1   0   2
    19     3     0   1   2
    20     3     0   0   3
    21     4     4   0   0
    22     4     3   1   0
    23     4     2   2   0
    24     4     1   3   0
    25     4     0   4   0
    26     4     3   0   1
    27     4     2   1   1
    28     4     1   2   1
    29     4     0   3   1
    30     4     2   0   2
    31     4     1   1   2
    32     4     0   2   2
    33     4     1   0   3
    34     4     0   1   3
    35     4     0   0   4
    36     5     5   0   0
    37     5     4   1   0
    38     5     3   2   0
    39     5     2   3   0
    40     5     1   4   0
    41     5     0   5   0
    42     5     4   0   1
    43     5     3   1   1
    44     5     2   2   1
    45     5     1   3   1
    46     5     0   4   1
    47     5     3   0   2
    48     5     2   1   2
    49     5     1   2   2
    50     5     0   3   2
    51     5     2   0   3
    52     5     1   1   3
    53     5     0   2   3
    54     5     1   0   4
    55     5     0   1   4
    56     5     0   0   5
    57     6     6   0   0
    58     6     5   1   0
    59     6     4   2   0
    60     6     3   3   0
    61     6     2   4   0
    62     6     1   5   0
    63     6     0   6   0
    64     6     5   0   1
    65     6     4   1   1
    66     6     3   2   1
    67     6     2   3   1
    68     6     1   4   1
    69     6     0   5   1
    70     6     4   0   2
    71     6     3   1   2
    72     6     2   2   2
    73     6     1   3   2
    74     6     0   4   2
    75     6     3   0   3
    76     6     2   1   3
    77     6     1   2   3
    78     6     0   3   3
    79     6     2   0   4
    80     6     1   1   4
    81     6     0   2   4
    82     6     1   0   5
    83     6     0   1   5
    84     6     0   0   6

SUBCOMPNZ_NEXT_test():
  SUBCOMPNZ_NEXT generates subcompositions
  using nonzero parts.

  Seek all subcompositions of N =        6
  using K =        3 nonzero parts.

     #   Sum

     1     3     1   1   1
     2     4     2   1   1
     3     4     1   2   1
     4     4     1   1   2
     5     5     3   1   1
     6     5     2   2   1
     7     5     1   3   1
     8     5     2   1   2
     9     5     1   2   2
    10     5     1   1   3
    11     6     4   1   1
    12     6     3   2   1
    13     6     2   3   1
    14     6     1   4   1
    15     6     3   1   2
    16     6     2   2   2
    17     6     1   3   2
    18     6     2   1   3
    19     6     1   2   3
    20     6     1   1   4

SUBCOMPNZ2_NEXT_test():
  SUBCOMPNZ2_NEXT generates subcompositions
  using nonzero parts.

  Seek all subcompositions of N
  using K =        3 nonzero parts.

  N ranges from        5 to        7

     #     N

     1     5     3   1   1
     2     5     2   2   1
     3     5     1   3   1
     4     5     2   1   2
     5     5     1   2   2
     6     5     1   1   3
     7     6     4   1   1
     8     6     3   2   1
     9     6     2   3   1
    10     6     1   4   1
    11     6     3   1   2
    12     6     2   2   2
    13     6     1   3   2
    14     6     2   1   3
    15     6     1   2   3
    16     6     1   1   4
    17     7     5   1   1
    18     7     4   2   1
    19     7     3   3   1
    20     7     2   4   1
    21     7     1   5   1
    22     7     4   1   2
    23     7     3   2   2
    24     7     2   3   2
    25     7     1   4   2
    26     7     3   1   3
    27     7     2   2   3
    28     7     1   3   3
    29     7     2   1   4
    30     7     1   2   4
    31     7     1   1   5

SUBSET_BY_SIZE_NEXT_test():
  SUBSET_BY_SIZE_NEXT generates all subsets of an N set.

     1     1 2 3 4 5
     2     1 2 3 4
     3     1 2 3 5
     4     1 2 4 5
     5     1 3 4 5
     6     2 3 4 5
     7     1 2 3
     8     1 2 4
     9     1 2 5
    10     1 3 4
    11     1 3 5
    12     1 4 5
    13     2 3 4
    14     2 3 5
    15     2 4 5
    16     3 4 5
    17     1 2
    18     1 3
    19     1 4
    20     1 5
    21     2 3
    22     2 4
    23     2 5
    24     3 4
    25     3 5
    26     4 5
    27     1
    28     2
    29     3
    30     4
    31     5
    32    The empty set

SUBSET_GRAY_NEXT_test():
  SUBSET_GRAY_NEXT generates all subsets of an N set.
  using the Gray code ordering:
  0 0 1 0 1 means the subset contains 3 and 5.

  Gray code

     1     0 0 0 0 0
     2     1 0 0 0 0
     3     1 1 0 0 0
     4     0 1 0 0 0
     5     0 1 1 0 0
     6     1 1 1 0 0
     7     1 0 1 0 0
     8     0 0 1 0 0
     9     0 0 1 1 0
    10     1 0 1 1 0
    11     1 1 1 1 0
    12     0 1 1 1 0
    13     0 1 0 1 0
    14     1 1 0 1 0
    15     1 0 0 1 0
    16     0 0 0 1 0
    17     0 0 0 1 1
    18     1 0 0 1 1
    19     1 1 0 1 1
    20     0 1 0 1 1
    21     0 1 1 1 1
    22     1 1 1 1 1
    23     1 0 1 1 1
    24     0 0 1 1 1
    25     0 0 1 0 1
    26     1 0 1 0 1
    27     1 1 1 0 1
    28     0 1 1 0 1
    29     0 1 0 0 1
    30     1 1 0 0 1
    31     1 0 0 0 1
    32     0 0 0 0 1

SUBSET_GRAY_RANK_test():
  SUBSET_GRAY_RANK returns rank of a subset of an N set
  using the Gray code ordering.

  For N =        5
  the subset is:
   1 0 1 1 0

  The rank is       28

SUBSET_GRAY_UNRANK_test():
  SUBSET_GRAY_UNRANK finds the subset of an N set
  of a given rank under the Gray code ordering.

  N is        5

  Rank   Subset

     1     0 0 0 0 0
     2     0 0 0 0 1
     3     0 0 0 1 1
     4     0 0 0 1 0
     5     0 0 1 1 0
     6     0 0 1 1 1
     7     0 0 1 0 1
     8     0 0 1 0 0
     9     0 1 1 0 0
    10     0 1 1 0 1

SUBSET_LEX_NEXT_test():
  SUBSET_LEX_NEXT generates all subsets of an N set.
  The user can impose a restriction on the
  maximum size of the subsets.

  Here, we require the subsets to be no larger
  than        3
   1
   1 2
   1 2 3
   1 2 4
   1 2 5
   1 3
   1 3 4
   1 3 5
   1 4
   1 4 5
   1 5
   2
   2 3
   2 3 4
   2 3 5
   2 4
   2 4 5
   2 5
   3
   3 4
   3 4 5
   3 5
   4
   4 5
   5
  The empty set.

SUBSET_RANDOM_test():
  SUBSET_RANDOM picks a subset at random.
  The number of elements in the main set is        5

   1 1 1 1 0
   0 1 1 0 1
   1 0 1 1 1
   1 1 1 1 0
   1 1 1 0 0

SUBTRIANGLE_NEXT_test():
  SUBTRIANGLE_NEXT generates the indices of subtriangles
  in a triangle whose edges were divided into N subedges.

  For this test, N =        4

  Rank    I1  J1    I2  J2    I3  J3

     1     0   0     1   0     0   1
     2     1   1     0   1     1   0
     3     1   0     2   0     1   1
     4     2   1     1   1     2   0
     5     2   0     3   0     2   1
     6     3   1     2   1     3   0
     7     3   0     4   0     3   1
     8     0   1     1   1     0   2
     9     1   2     0   2     1   1
    10     1   1     2   1     1   2
    11     2   2     1   2     2   1
    12     2   1     3   1     2   2
    13     0   2     1   2     0   3
    14     1   3     0   3     1   2
    15     1   2     2   2     1   3
    16     0   3     1   3     0   4

THUE_BINARY_NEXT_test():
  THUE_BINARY_NEXT returns the next Thue binary sequence.

     1    0
     2    01
     4    0110
     8    01101001
    16    0110100110010110
    32    01101001100101101001011001101001
    64    0110100110010110100101100110100110010110011010010110100110010110

THUE_TERNARY_NEXT_test():
  THUE_TERNARY_NEXT returns the next 
  Thue ternary sequence.

     1    1
     3    102
     6    102120
    12    102120102012
    24    102120102012102120121020
    48    102120102012102120121020102120102012102010212012

TRIANG_test():
  TRIANG relabels elements for a partial ordering,

  The input matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        1      0      0      0      0      0      0      0      0      0
       2        0      1      0      1      0      1      0      1      0      0
       3        1      0      1      1      0      0      0      0      0      0
       4        0      0      0      1      0      0      0      0      0      0
       5        1      1      1      1      1      1      1      1      0      1
       6        0      0      0      1      0      1      0      1      0      0
       7        1      0      1      1      0      1      1      1      0      1
       8        0      0      0      1      0      0      0      1      0      0
       9        0      0      0      0      0      0      0      0      0      0
      10        1      0      1      1      0      0      0      1      0      1

  The new ordering:

     1   2   3   4   5   6   7   8   9  10
     5   6   4   9   1   7   2   8  10   3

  The reordered matrix:

  Col         1      2      3      4      5      6      7      8      9     10
  Row

       1        1      1      1      1      1      1      1      1      1      0
       2        0      1      1      1      1      0      1      1      1      0
       3        0      0      1      1      1      0      0      1      1      0
       4        0      0      0      1      1      0      0      0      1      0
       5        0      0      0      0      1      0      0      0      0      0
       6        0      0      0      0      0      1      1      1      1      0
       7        0      0      0      0      0      0      1      1      1      0
       8        0      0      0      0      0      0      0      1      1      0
       9        0      0      0      0      0      0      0      0      1      0
      10        0      0      0      0      0      0      0      0      0      0

TUPLE_NEXT_test():
  TUPLE_NEXT returns the next "tuple", that is,
  a vector of N integers, each between M1 and M2.

  M1 =        2
  M2 =        4
  N =         2

     1    2  2
     2    2  3
     3    2  4
     4    3  2
     5    3  3
     6    3  4
     7    4  2
     8    4  3
     9    4  4

TUPLE_NEXT_FAST_test():
  TUPLE_NEXT_FAST returns the next "tuple", that is,
  a vector of N integers, each between 1 and M.

  M =        3
  N =        2

     0    1  1
     1    1  2
     2    1  3
     3    2  1
     4    2  2
     5    2  3
     6    3  1
     7    3  2
     8    3  3

TUPLE_NEXT_GE_test():
  TUPLE_NEXT_GE returns the next "tuple", that is,
  a vector of N integers, each between 1 and M,
  with the constraint that the entries be
  nondecreasing.

  M =        3
  N =        3

     1    1  1  1
     2    1  1  2
     3    1  1  3
     4    1  2  2
     5    1  2  3
     6    1  3  3
     7    2  2  2
     8    2  2  3
     9    2  3  3
    10    3  3  3

TUPLE_NEXT2_test():
  TUPLE_NEXT2 returns the next "tuple", that is,
  a vector of N integers.

  N =        3

  The minimum tuple is 
         2       3       8
  The maximum tuple is 
         4       3       5

     1    2  3  8
     2    2  3  7
     3    2  3  6
     4    2  3  5
     5    3  3  8
     6    3  3  7
     7    3  3  6
     8    3  3  5
     9    4  3  8
    10    4  3  7
    11    4  3  6
    12    4  3  5

UBVEC_ADD_test():
  UBVEC_ADD adds unsigned binary vectors
  representing unsigned integers;

        I        J        K = I + J


        55        52
  Directly:                107
  UBVEC_ADD                107

        28        94
  Directly:                122
  UBVEC_ADD                122

        33        49
  Directly:                 82
  UBVEC_ADD                 82

        22        83
  Directly:                105
  UBVEC_ADD                105

        60        37
  Directly:                 97
  UBVEC_ADD                 97

         6        25
  Directly:                 31
  UBVEC_ADD                 31

        45        27
  Directly:                 72
  UBVEC_ADD                 72

        52        17
  Directly:                 69
  UBVEC_ADD                 69

        78        84
  Directly:                162
  UBVEC_ADD                162

        87        18
  Directly:                105
  UBVEC_ADD                105

UBVEC_PRINT_test():
  UBVEC_PRINT prints an unsigned binary vector.

  UBVEC:
  1001011100

UBVEC_TO_UI4_test():
  UBVEC_TO_UI4 converts an unsigned binary vector
  to an unsigned integer;

  I --> BVEC  -->  I

    0  0000000000    0
    1  0000000001    1
    2  0000000010    2
    3  0000000011    3
    4  0000000100    4
    5  0000000101    5
    6  0000000110    6
    7  0000000111    7
    8  0000001000    8
    9  0000001001    9
   10  0000001010   10

UBVEC_XOR_test():
  UBVEC_XOR computes the exclusive OR of two
  unsigned binary vectors representing unsigned integers;

        I        J        K = I XOR J

        89        99        58
        95        89         6
        25        79        86
        51        56        11
        89        84        13
        36        36         0
        49        82        99
        94        64        30
        34         5        39
         1        50        51

UI4_TO_UBVEC_test():
  UI4_TO_UBVEC converts an unsigned integer to an 
  unsigned binary vector;

  I --> BVEC  -->  I

    0  0000000000    0
    1  0000000001    1
    2  0000000010    2
    3  0000000011    3
    4  0000000100    4
    5  0000000101    5
    6  0000000110    6
    7  0000000111    7
    8  0000001000    8
    9  0000001001    9
   10  0000001010   10

VEC_COLEX_NEXT_test():
  VEC_COLEX_NEXT generates all DIM_NUM-vectors
  in colex order in a given base BASE.

  The dimension DIM_NUM =        3
  The base BASE =                3

     0   0   0
     1   0   0
     2   0   0
     0   1   0
     1   1   0
     2   1   0
     0   2   0
     1   2   0
     2   2   0
     0   0   1
     1   0   1
     2   0   1
     0   1   1
     1   1   1
     2   1   1
     0   2   1
     1   2   1
     2   2   1
     0   0   2
     1   0   2
     2   0   2
     0   1   2
     1   1   2
     2   1   2
     0   2   2
     1   2   2
     2   2   2

VEC_COLEX_NEXT2_test():
  VEC_COLEX_NEXT2 generates all DIM_NUM-vectors
  in colex order in given bases BASE(1:DIM_NUM).

  The dimension DIM_NUM =        3

  The base vector:

     2   1   3

     0   0   0
     1   0   0
     0   0   1
     1   0   1
     0   0   2
     1   0   2

VEC_COLEX_NEXT3_test():
  VEC_COLEX_NEXT3 generates all DIM_NUM-vectors
  in colex order in given bases BASE(1:DIM_NUM).

  The dimension DIM_NUM =        3

  The base vector:

     2   1   3

     1   1   1
     2   1   1
     1   1   2
     2   1   2
     1   1   3
     2   1   3

VEC_GRAY_NEXT_test():
  VEC_GRAY_NEXT generates product space elements.

  The number of components is        4
  The number of elements is       16
  Each component has its own number of degrees of
  freedom.

  Rank Change        2   2   1   4

     1     1         0   0   0   0
     2     4         0   0   0   1
     3     4         0   0   0   2
     4     4         0   0   0   3
     5     2         0   1   0   3
     6     4         0   1   0   2
     7     4         0   1   0   1
     8     4         0   1   0   0
     9     1         1   1   0   0
    10     4         1   1   0   1
    11     4         1   1   0   2
    12     4         1   1   0   3
    13     2         1   0   0   3
    14     4         1   0   0   2
    15     4         1   0   0   1
    16     4         1   0   0   0

VEC_GRAY_RANK_test():
  VEC_GRAY_RANK ranks product space elements.
  VEC_GRAY_UNRANK unranks them.

  The number of components is        4
  The number of elements is       16
  Each component has its own number of degrees of
  freedom, which, for this example, are:

  Rank Change        2   2   1   4


  VEC_GRAY_RANK reports the element 

          1   1   0   2

  has rank       11

VEC_GRAY_UNRANK_test():
  VEC_GRAY_UNRANK unranks product space elements.

  The number of components is        4
  The number of elements is       16
  Each component has its own number of degrees of
  freedom, which, for this example, are:

  Rank Change        2   2   1   4


  VEC_GRAY_UNRANK reports the element of rank        7
  is:

          0   1   0   1


VEC_LEX_NEXT_test():
  VEC_LEX_NEXT generates all N-vectors
  in a given base.  Here we use base        3

     0   0   0
     0   0   1
     0   0   2
     0   1   0
     0   1   1
     0   1   2
     0   2   0
     0   2   1
     0   2   2
     1   0   0
     1   0   1
     1   0   2
     1   1   0
     1   1   1
     1   1   2
     1   2   0
     1   2   1
     1   2   2
     2   0   0
     2   0   1
     2   0   2
     2   1   0
     2   1   1
     2   1   2
     2   2   0
     2   2   1
     2   2   2

VEC_RANDOM_test():
  VEC_RANDOM generates a random N-vector
  in a given base.
  Here, we use base        3

     1   2   0
     2   1   0
     2   1   2
     1   2   0
     0   1   1

VECTOR_CONSTRAINED_NEXT_test():
  VECTOR_CONSTRAINED_NEXT:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( (X(1:N)-1) * P / X_MAX(1:N) ) <= P

  X_MIN:   2   2   1
  X_MAX:   4   5   3

  Maximum allowed CONSTRAINT = P =           60

         1            27         2         2         1
         2            42         3         2         1
         3            57         4         2         1
         4            39         2         3         1
         5            54         3         3         1
         6            51         2         4         1
         7            47         2         2         2
         8            59         2         3         2

VECTOR_CONSTRAINED_NEXT2_test():
  VECTOR_CONSTRAINED_NEXT2:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    P = Product X_MAX(1:N)
  Accept only vectors for which:
    sum ( X(1:N) * P / X_MAX(1:N) ) <= P

  X_MIN:   1   1
  X_MAX:   5   6

  Maximum allowed CONSTRAINT = P =           30

         1            11         1         1
         2            17         2         1
         3            23         3         1
         4            29         4         1
         5            16         1         2
         6            22         2         2
         7            28         3         2
         8            21         1         3
         9            27         2         3
        10            26         1         4

  X_MIN:   1   1   1
  X_MAX:   5   6   4

  Maximum allowed CONSTRAINT = P =          120

         1            74         1         1         1
         2            98         2         1         1
         3            94         1         2         1
         4           118         2         2         1
         5           114         1         3         1
         6           104         1         1         2

VECTOR_CONSTRAINED_NEXT3_test():
  VECTOR_CONSTRAINED_NEXT3:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    CONSTRAINT = sum ( X(1:N) / X_MAX(1:N) )
  Accept only vectors for which:
    CONSTRAINT <= 1

  X_MIN:   1   1
  X_MAX:   5   6

         1    0.366667             1         1
         2    0.566667             2         1
         3    0.766667             3         1
         4    0.966667             4         1
         5    0.533333             1         2
         6    0.733333             2         2
         7    0.933333             3         2
         8    0.700000             1         3
         9    0.900000             2         3
        10    0.866667             1         4

  X_MIN:   1   1   1
  X_MAX:   5   6   4

         1    0.616667             1         1         1
         2    0.816667             2         1         1
         3    0.783333             1         2         1
         4    0.983333             2         2         1
         5    0.950000             1         3         1
         6    0.866667             1         1         2

VECTOR_CONSTRAINED_NEXT4_test():
  VECTOR_CONSTRAINED_NEXT4:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    TOTAL <= Q

  ALPHA:   4.00000       3.00000    
  Q:       20.0000    
  X_MIN:   1   0
  X_MAX:   2   6

         1     4.00000             1         0
         2     8.00000             2         0
         3     7.00000             1         1
         4     11.0000             2         1
         5     10.0000             1         2
         6     14.0000             2         2
         7     13.0000             1         3
         8     17.0000             2         3
         9     16.0000             1         4
        10     20.0000             2         4
        11     19.0000             1         5

  ALPHA:   4.00000       3.00000       5.00000    
  Q:       20.0000    
  X_MIN:   1   0   1
  X_MAX:   2   6   4

         1     9.00000             1         0         1
         2     13.0000             2         0         1
         3     12.0000             1         1         1
         4     16.0000             2         1         1
         5     15.0000             1         2         1
         6     19.0000             2         2         1
         7     18.0000             1         3         1
         8     14.0000             1         0         2
         9     18.0000             2         0         2
        10     17.0000             1         1         2
        11     20.0000             1         2         2
        12     19.0000             1         0         3

VECTOR_CONSTRAINED_NEXT5_test():
  VECTOR_CONSTRAINED_NEXT5:
  Generate integer vectors X such that:
    SUM_MIN <= sum ( X(1:N) ) <= SUM_MAX,
  We require every X(I) to be at least 1.

  N =              3
  SUM_MIN =        5
  SUM_MAX =        7

         #        X(1)      X(2)      X(3)

         1         3         1         1
         2         2         2         1
         3         2         1         2
         4         1         3         1
         5         1         2         2
         6         1         1         3
         7         4         1         1
         8         3         2         1
         9         3         1         2
        10         2         3         1
        11         2         2         2
        12         2         1         3
        13         1         4         1
        14         1         3         2
        15         1         2         3
        16         1         1         4
        17         5         1         1
        18         4         2         1
        19         4         1         2
        20         3         3         1
        21         3         2         2
        22         3         1         3
        23         2         4         1
        24         2         3         2
        25         2         2         3
        26         2         1         4
        27         1         5         1
        28         1         4         2
        29         1         3         3
        30         1         2         4
        31         1         1         5

VECTOR_CONSTRAINED_NEXT6_test():
  VECTOR_CONSTRAINED_NEXT6:
  Consider vectors:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX

  ALPHA:   4.00000       3.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MIN:   1   0
  X_MAX:   2   6

         1     16.0000             1         4
         2     19.0000             1         5
         3     17.0000             2         3
         4     20.0000             2         4

  ALPHA:   4.00000       3.00000       5.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MIN:   1   0   1
  X_MAX:   2   6   4

         1     19.0000             1         0         3
         2     17.0000             1         1         2
         3     20.0000             1         2         2
         4     18.0000             1         3         1
         5     18.0000             2         0         2
         6     16.0000             2         1         1
         7     19.0000             2         2         1

VECTOR_CONSTRAINED_NEXT7_test():
  VECTOR_CONSTRAINED_NEXT7:
  Consider vectors:
    0 <= X(1:N) <= X_MAX(1:N),
  Set
    TOTAL = sum ( ALPHA(1:N) * X(1:N) )
  Accept only vectors for which:
    Q_MIN <= TOTAL <= Q_MAX

  ALPHA:   4.00000       3.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MAX:   2   6

         1     18.0000             0         6
         2     19.0000             1         5
         3     17.0000             2         3
         4     20.0000             2         4

  ALPHA:   4.00000       3.00000       5.00000    
  Q_MIN:   16.0000    
  Q_MAX:   20.0000    
  X_MAX:   2   6   4

         1     20.0000             0         0         4
         2     18.0000             0         1         3
         3     19.0000             0         3         2
         4     17.0000             0         4         1
         5     20.0000             0         5         1
         6     18.0000             0         6         0
         7     19.0000             1         0         3
         8     17.0000             1         1         2
         9     20.0000             1         2         2
        10     18.0000             1         3         1
        11     19.0000             1         5         0
        12     18.0000             2         0         2
        13     19.0000             2         2         1
        14     17.0000             2         3         0
        15     20.0000             2         4         0

VECTOR_NEXT_test():
  VECTOR_NEXT:
  Generate all vectors X such that:
    X_MIN(1:N) <= X(1:N) <= X_MAX(1:N),

  XMIN           1         4
     1           1         4
     2           2         4
     3           1         5
     4           2         5
     5           1         6
     6           2         6
  XMAX           2         6

  XMIN           1         4         3
     1           1         4         3
     2           2         4         3
     3           1         5         3
     4           2         5         3
     5           1         6         3
     6           2         6         3
     7           1         4         4
     8           2         4         4
     9           1         5         4
    10           2         5         4
    11           1         6         4
    12           2         6         4
  XMAX           2         6         4

vector_sumlex_next_test():
  vector_sumlex_next() generates integer vectors of dimension n.
  The vectors are listed in order by the sum of their entries.
  For a given sum, vectors are listed in lexicographic order.
   0      0  0  0  0
   1      0  0  0  1
   2      0  0  1  0
   3      0  1  0  0
   4      1  0  0  0
   5      0  0  0  2
   6      0  0  1  1
   7      0  0  2  0
   8      0  1  0  1
   9      0  1  1  0
  10      0  2  0  0
  11      1  0  0  1
  12      1  0  1  0
  13      1  1  0  0
  14      2  0  0  0
  15      0  0  0  3
  16      0  0  1  2
  17      0  0  2  1
  18      0  0  3  0
  19      0  1  0  2
  20      0  1  1  1
  21      0  1  2  0
  22      0  2  0  1
  23      0  2  1  0
  24      0  3  0  0
  25      1  0  0  2
  26      1  0  1  1
  27      1  0  2  0
  28      1  1  0  1
  29      1  1  1  0
  30      1  2  0  0

ytb_conjugate_test():
  ytb_conjugate() conjugates a Young table.

  A Young tableau:

   1   2   6
   3   4
   5

  The conjugate Young tableau:

   1   3   5
   2   4
   6

ytb_enum_test():
  ytb_enum() counts Young tables.

  N    YTB(N)

           0         0
           1         1
           2         2
           3         4
           4        10
           5        26
           6        76
           7       232
           8       764
           9      2620
          10      9496

ytb_next_test():
  ytb_next() generates Young tables.


   1   4   6
   2   5
   3

   1   3   6
   2   5
   4

   1   2   6
   3   5
   4

   1   3   6
   2   4
   5

   1   2   6
   3   4
   5

   1   4   5
   2   6
   3

   1   3   5
   2   6
   4

   1   2   5
   3   6
   4

   1   3   4
   2   6
   5

   1   2   4
   3   6
   5

   1   2   3
   4   6
   5

   1   3   5
   2   4
   6

   1   2   5
   3   4
   6

   1   3   4
   2   5
   6

   1   2   4
   3   5
   6

   1   2   3
   4   5
   6

ytb_random_test():
  ytb_random() generates a random Young table

   1   3   6
   2   4
   5

   1   3   5
   2   6
   4

   1   3   5
   2   6
   4

   1   3   4
   2   5
   6

   1   3   5
   2   4
   6

subset_test():
  Normal end of execution.

22 June 2024   8:51:33.493 PM
